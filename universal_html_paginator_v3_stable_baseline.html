<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal HTML to Print Paginator v2</title>
    <!-- jsPDF and html2canvas for direct PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* Print styles */
        @page {
            size: A4;
            margin: 0;
        }

        @media print {
            /* ULTIMATE OVERRIDE: Reset everything for absolute print control */
            *, *::before, *::after {
                -webkit-print-color-adjust: exact !important;
                color-adjust: exact !important;
                box-sizing: border-box !important;
            }
            
            html, body {
                margin: 0 !important;
                padding: 0 !important;
                background: white !important;
                max-width: none !important;
                overflow: visible !important;
                height: auto !important;
                min-height: auto !important;
            }
            
            /* ABSOLUTE PAGE CONTROL: Force Chrome to treat each page as a separate print page */
            .page {
                page-break-after: always !important;
                page-break-before: auto !important;
                page-break-inside: avoid !important;
                break-after: page !important;
                break-before: auto !important;
                break-inside: avoid-page !important;
                margin: 0 !important;
                padding: 0.6cm !important;
                box-shadow: none !important;
                border: none !important;
                background: white !important;
                width: 210mm !important;
                height: 297mm !important;
                max-height: 297mm !important;
                min-height: 297mm !important;
                display: block !important;
                overflow: hidden !important;
                position: relative !important;
                contain: layout style paint size !important;
                isolation: isolate !important;
            }
            
            .page:last-child {
                page-break-after: auto !important;
                break-after: auto !important;
            }
            
            /* ATOMIC CONTENT: Make page content indivisible */
            .page-content {
                page-break-inside: avoid !important;
                break-inside: avoid-page !important;
                height: auto !important;
                max-height: 285.4mm !important;
                overflow: visible !important;
                display: block !important;
                contain: layout style !important;
            }
            
            /* NUCLEAR OVERRIDE: Every element within pages is indivisible */
            .page *, .page *::before, .page *::after {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                page-break-before: auto !important;
                break-before: auto !important;
                page-break-after: auto !important;
                break-after: auto !important;
            }
            
            /* MAXIMUM TABLE PROTECTION */
            table, caption, thead, tbody, tfoot, tr, th, td {
                page-break-inside: avoid !important;
                break-inside: avoid-page !important;
                page-break-before: auto !important;
                break-before: auto !important;
                page-break-after: auto !important;
                break-after: auto !important;
                overflow: visible !important;
                contain: none !important;
            }
            
            /* STYLED CONTAINER ABSOLUTE PROTECTION */
            .callout, [class*="callout"], .warning, .success, .info, .alert, .card, .box,
            div[style*="background"], div[style*="border"], div[style*="box-shadow"],
            div[style*="padding"], div[style*="margin"] {
                page-break-inside: avoid !important;
                break-inside: avoid-page !important;
                display: block !important;
                overflow: visible !important;
                contain: none !important;
            }
            
            /* HEADING COHESION */
            h1, h2, h3, h4, h5, h6 {
                page-break-after: avoid !important;
                break-after: avoid !important;
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                keep-with-next: always !important;
                contain: none !important;
            }
            
            /* TEXT FLOW CONTROL */
            p, ul, ol, li, blockquote, div, span {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                orphans: 4 !important;
                widows: 4 !important;
                contain: none !important;
            }
            
            /* HIDE NON-PRINT ELEMENTS */
            .controls, .file-input, .source-content, .status, .debug-info, .measurement-container {
                display: none !important;
                visibility: hidden !important;
            }
            
            /* FORCE PAGINATED CONTENT VISIBILITY */
            .paginated-content {
                display: block !important;
                visibility: visible !important;
                position: static !important;
                contain: none !important;
            }
            
            /* CHROME HACK: Force physical page dimensions */
            @page {
                size: A4 !important;
                margin: 0 !important;
                padding: 0 !important;
            }
        }

        /* General styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Helvetica, Arial, sans-serif;
            background: white;
            padding: 20px;
            line-height: 1.4;
            width: 100%;
            min-height: 100vh;
        }
        
        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            background: white;
        }

        /* Page container for screen view */
        .page {
            width: 210mm;
            min-height: 297mm;
            background: white;
            margin: 0 auto 20px auto;
            padding: 0.6cm;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #ccc;
            position: relative;
            page-break-after: always;
        }

        /* Page content area - Let JavaScript handle height constraints */
        .page-content {
            /* No height constraints - pure JavaScript pagination logic */
        }

        /* Controls */
        .controls {
            text-align: center;
            margin: 0 auto 30px auto;
            background: #f8f8f8;
            padding: 25px;
            border-radius: 12px;
            border: 2px solid #000;
            color: black;
            width: 800px;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .controls h2 {
            margin: 0 0 20px 0;
            font-size: 24px;
            font-weight: bold;
            font-family: Helvetica, Arial, sans-serif;
            color: black;
        }

        .controls button {
            padding: 10px 14px;
            margin: 0;
            border: 2px solid #000;
            background: #f0f8ff;
            color: black;
            cursor: pointer;
            border-radius: 8px;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
        }
        
        .button-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            flex-wrap: nowrap;
            margin-bottom: 20px;
        }
        
        .button-row button {
            flex: 0 0 auto;
        }

        .controls button:hover {
            background: #e0f0ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .controls button:disabled {
            background: #ccc !important;
            color: #666 !important;
            cursor: not-allowed !important;
            opacity: 0.6 !important;
            transform: none !important;
            box-shadow: none !important;
        }

        .controls button:disabled:hover {
            background: #ccc !important;
            transform: none !important;
            box-shadow: none !important;
        }
        
        /* Workflow step indicators */
        .workflow-step {
            display: inline-block;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #ccc;
            color: white;
            text-align: center;
            line-height: 24px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        .workflow-step.completed {
            background: #4CAF50;
        }
        
        .workflow-step.active {
            background: #2196F3;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .controls button.primary {
            background: #4CAF50;
            color: white;
            border-color: #000;
        }

        .controls button.primary:hover {
            background: #45a049;
        }

        /* File input area */
        .file-input {
            background: #fffef7;
            border: 2px solid #000;
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            margin: 20px 0;
            font-family: Helvetica, Arial, sans-serif;
        }

        .file-input:hover {
            background: #fff8e1;
        }

        .file-input.dragover {
            border-color: #4CAF50;
            background: #f9f9f9;
        }

        .upload-button {
            margin: 15px 0;
            padding: 12px 30px;
            border: 2px solid #000;
            border-radius: 25px;
            background: #f0f8ff;
            color: black;
            font-family: Helvetica, Arial, sans-serif;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .upload-button:hover {
            background: #e0f0ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .html-input {
            width: 100%;
            height: 200px;
            margin: 10px 0;
            padding: 15px;
            border: 2px solid #000;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            font-weight: normal;
            background: #f8fff8;
            resize: vertical;
        }
        
        .html-input:focus {
            outline: none;
            background: #f0fff0;
        }

        /* Source content (shown initially) */
        .source-content {
            display: block;
            width: 800px;
            max-width: 100%;
            margin: 0 auto 20px auto;
            background: white;
            padding: 0.6cm;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #ccc;
            box-sizing: border-box;
        }
        
        /* Paginated content container */
        .paginated-content {
            margin: 0 auto;
            max-width: 1200px;
        }

        /* Ensure content fits properly within page bounds */
        .source-content *,
        .page-content * {
            max-width: 100%;
            box-sizing: border-box;
        }

        /* Status and debug info */
        .status {
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
            color: #666;
        }


        /* Measurement container (hidden) */
        .measurement-container {
            position: absolute;
            top: -9999px;
            left: -9999px;
            visibility: hidden;
            width: 210mm;
            padding: 0.6cm;
        }
    </style>
</head>
<body>
    <div class="main-container">
    <div class="controls">
        <h2>Universal HTML to Print Paginator v2</h2>
        <p>Transform any HTML content into perfectly paginated A4 print layouts</p>
        
        <div class="file-input" id="fileInput">
            <p style="margin-bottom: 15px;"><strong>Method 1:</strong> Upload HTML File</p>
            <input type="file" accept=".html,.htm" id="htmlFile" style="display: none;">
            <button class="upload-button" onclick="document.getElementById('htmlFile').click()">📁 Choose HTML File</button>
        </div>
        
        <div class="button-row">
            <button onclick="processHTML()" id="processBtn" class="primary">
                <span class="workflow-step active" id="step1">1</span>✨ Process HTML
            </button>
            
            <button onclick="paginateContent()" id="paginateBtn" disabled>
                <span class="workflow-step" id="step2">2</span>📖 Paginate
            </button>
            
            <button onclick="printPaginated()" id="printBtn" disabled>
                <span class="workflow-step" id="step3a">3</span>🖨️ Print
            </button>
            
            <button onclick="downloadPDF()" id="downloadBtn" disabled style="background: #e74c3c; border-color: #000;">
                <span class="workflow-step" id="step3b">3</span>📄 Download PDF
            </button>
        </div>
        
        <div style="margin-top: 15px; padding: 12px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; font-size: 13px; color: #856404;">
            <strong>📋 Print Settings:</strong> For perfect results, set Chrome print margins to <strong>"None"</strong> (not Default). Keep scale at 100% and paper size as A4. <br>
            <strong>💡 Best Quality:</strong> Use <strong>"Download PDF"</strong> for direct PDF generation that captures your perfect pagination exactly as shown on screen!
        </div>
    </div>

    <div class="status" id="status">Ready - Upload HTML file or paste content above</div>
    

    <!-- Hidden measurement container -->
    <div class="measurement-container" id="measurementContainer">
        <!-- Cloned content for measurement will go here -->
    </div>

    <!-- Source content container -->
    <div class="source-content" id="sourceContent" style="display: none;">
        <!-- Original content will be displayed here -->
    </div>

    <!-- Paginated content container -->
    <div class="paginated-content" id="paginatedContent">
        <!-- Paginated pages will be generated here -->
    </div>

    <script>
        let originalHTML = '';
        let processedElements = [];
        let elementHeights = [];
        let preservedStyles = ''; // Store extracted styles globally
        let uploadedHTMLContent = ''; // Store uploaded HTML content

        // Initialize the application
        function init() {
            console.log('Universal HTML Paginator v2 initialized');
            
            // Initialize workflow states - only step 1 is active, others disabled
            document.getElementById('step1').className = 'workflow-step active';
            document.getElementById('step2').className = 'workflow-step';
            document.getElementById('step3a').className = 'workflow-step';
            document.getElementById('step3b').className = 'workflow-step';
            
            // Initial button states
            document.getElementById('processBtn').disabled = false;
            document.getElementById('paginateBtn').disabled = true;
            document.getElementById('printBtn').disabled = true;
            document.getElementById('downloadBtn').disabled = true;
            
            // Set up file input handlers
            const fileInput = document.getElementById('htmlFile');
            const fileInputArea = document.getElementById('fileInput');
            
            fileInput.addEventListener('change', handleFileSelect);
            
            // Set up drag and drop
            fileInputArea.addEventListener('dragover', handleDragOver);
            fileInputArea.addEventListener('drop', handleDrop);
            fileInputArea.addEventListener('dragenter', (e) => {
                e.preventDefault();
                fileInputArea.classList.add('dragover');
            });
            fileInputArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                fileInputArea.classList.remove('dragover');
            });
        }

        // Handle file selection
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && (file.type === 'text/html' || file.name.endsWith('.html') || file.name.endsWith('.htm'))) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    uploadedHTMLContent = e.target.result;
                    updateStatus('HTML file loaded successfully');
                };
                reader.readAsText(file);
            } else {
                updateStatus('Please select a valid HTML file', 'error');
            }
        }

        // Handle drag and drop
        function handleDragOver(event) {
            event.preventDefault();
        }

        function handleDrop(event) {
            event.preventDefault();
            document.getElementById('fileInput').classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'text/html' || file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        uploadedHTMLContent = e.target.result;
                        updateStatus('HTML file dropped and loaded successfully');
                    };
                    reader.readAsText(file);
                } else {
                    updateStatus('Please drop a valid HTML file', 'error');
                }
            }
        }

        // Update status message
        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.style.color = type === 'error' ? '#d32f2f' : type === 'success' ? '#388e3c' : '#666';
        }


        // Print paginated content only
        function printPaginated() {
            // Ensure paginated content is visible
            document.getElementById('sourceContent').style.display = 'none';
            document.getElementById('paginatedContent').style.display = 'block';
            
            // Check if we have paginated content
            const paginatedContent = document.getElementById('paginatedContent');
            if (!paginatedContent.children.length) {
                alert('Please paginate the content first before printing.');
                return;
            }
            
            updateStatus('Preparing paginated content for print...');
            // Print
            window.print();
        }


        // Show paginated content
        function showPaginated() {
            document.getElementById('sourceContent').style.display = 'none';
            document.getElementById('paginatedContent').style.display = 'block';
            updateStatus('Showing paginated content');
        }

        // CSS Sanitization Engine - remove pagination-breaking rules
        function sanitizeCSS(htmlContent) {
            console.log('Starting CSS sanitization...');
            
            // Remove CSS rules that break pagination flow, but preserve spacing and visual styling
            const problematicRules = [
                /page-break-[^;]*;/gi,
                /break-[^;]*;/gi,
                /@page[^}]*}/gi,
                /height:\s*100vh[^;]*;/gi,          // Remove viewport heights
                /min-height:\s*100vh[^;]*;/gi,
                /height:\s*100%[^;]*;/gi,           // Remove 100% heights that cause issues
                /min-height:\s*100%[^;]*;/gi,
                /height:\s*297mm[^;]*;/gi,          // Remove fixed A4 page heights
                /min-height:\s*297mm[^;]*;/gi,      // Remove fixed A4 min-heights
                /height:\s*var\(--page-height\)[^;]*;/gi,  // Remove CSS custom property heights
                /width:\s*var\(--page-width\)[^;]*;/gi,   // Remove CSS custom property widths
                /#pages\s*\{[^}]*\}/gi,             // Remove #pages container styling that causes layout issues
                /\.page-content\s*\{[^}]*position:\s*absolute[^}]*\}/gi, // Remove absolute positioning from page-content
                /position:\s*absolute[^;]*;/gi,     // Remove all absolute positioning
                /position:\s*relative[^;]*;/gi,     // Remove relative positioning that can cause issues
                /overflow:\s*hidden[^;]*;/gi,       // Remove overflow:hidden that prevents scrolling
                /height:\s*calc\([^)]*\)[^;]*;/gi,  // Remove calc() heights that constrain flow
                /max-height:\s*[^;]*vh[^;]*;/gi,    // Remove viewport-based max heights
                /\.page-content\s*\{[^}]*overflow:\s*hidden[^;]*;/gi,  // Only remove overflow:hidden from page-content specifically
                /width:\s*793px[^;]*;/gi,           // Remove hardcoded 793px width that breaks layout
                /width:\s*210mm[^;]*;/gi,           // Remove fixed A4 page widths that might constrain
                /body\s*\{[^}]*background[^}]*\}/gi, // Remove body background that might cause artifacts
                /\.page\s*\{[^}]*height:[^}]*\}/gi,  // Remove .page class height constraints
                /\.page\s*\{[^}]*min-height:[^}]*\}/gi // Remove .page class min-height constraints
            ];
            
            let sanitized = htmlContent;
            problematicRules.forEach(rule => {
                sanitized = sanitized.replace(rule, '');
            });
            
            // Comprehensive CSS fixes for all common HTML document formatting issues
            const spacingPreservationCSS = `
            <style>
            /* ========== LIST FORMATTING ========== */
            ul, ol {
                padding-left: 2.5em !important;
            }
            
            /* ========== SPACING PRESERVATION ========== */
            /* Preserve spacing and styling for specific content elements */
            .page-content .stat-box {
                margin: 8pt 0 !important;
                background-color: #00CCCC !important; /* Ensure cyan background is preserved */
                color: white !important;
                padding: 10pt !important;
                border-radius: 4pt !important;
                text-align: center !important;
                font-weight: bold !important;
            }
            .page-content .text-box {
                margin: 12pt 0 !important;
            }
            .page-content .callout {
                margin: 15px 0 !important;
                padding: 10px 15px !important;
            }
            
            /* Preserve spacing between paragraphs and special elements */
            .page-content p + .text-box,
            .page-content p + .callout,
            .page-content p + .stat-box {
                margin-top: 12pt !important;
            }
            .page-content .text-box + p,
            .page-content .callout + p,
            .page-content .stat-box + p {
                margin-top: 12pt !important;
            }
            .page-content p + p {
                margin-top: 1em !important;
            }
            
            /* Heading spacing */
            .page-content h1, .page-content h2, .page-content h3, .page-content h4, .page-content h5, .page-content h6 {
                margin-top: 1.5em !important;
                margin-bottom: 0.5em !important;
                color: inherit !important;
            }
            .page-content h1:first-child, .page-content h2:first-child, .page-content h3:first-child {
                margin-top: 0 !important;
            }
            
            /* ========== PROGRAMMATIC STYLE PRESERVATION PLACEHOLDER ========== */
            /* Styles will be dynamically generated by preserveVisualFidelity() function */
            /* This ensures 100% visual fidelity without hardcoding document-specific rules */
            
            /* ========== CONTAINER FIXES ========== */
            /* MINIMAL container fixes - only remove problematic overlays, preserve visual styling */
            
            /* Only remove extra white overlays that block visual elements - preserve intentional styling */
            .page-content .table-container:not([style*="background:"]):not([class*="styled"]) {
                background: transparent !important;
                box-shadow: none !important;
            }
            
            /* Remove only unintentional white container backgrounds that create artifacts */
            .page-content .container:not([style*="background:"]):not(.stat-box):not(.text-box):not(.callout):not(.reference-box) {
                background: transparent !important;
                box-shadow: none !important;
            }
            
            /* Preserve margins for styled elements */
            .page-content div[style*="margin"] {
                margin: inherit !important;
            }
            .page-content div[class*="card"] {
                margin: inherit !important;
            }
            .page-content div[class*="container"] {
                margin: inherit !important;
            }
            .page-content div[style*="background"] {
                margin: inherit !important;
            }
            .page-content div[style*="border"] {
                margin: inherit !important;
            }
            
            /* ========== TEXT AND COLOR FIXES ========== */
            /* Ensure text remains visible */
            .page-content p, .page-content li, .page-content span {
                color: inherit !important;
            }
            
            /* Link styling preservation */
            .page-content a {
                color: #3498db !important;
                text-decoration: none !important;
            }
            .page-content a:hover {
                text-decoration: underline !important;
            }
            
            /* ========== BACKGROUND FIXES ========== */
            /* Remove problematic backgrounds that cause artifacts */
            .page-content body {
                background: transparent !important;
            }
            .page-content html {
                background: transparent !important;
            }
            
            /* Preserve intended backgrounds for content elements */
            .page-content .stat-box,
            .page-content .text-box,
            .page-content .callout,
            .page-content .reference-box,
            .page-content [class*="box"],
            .page-content [style*="background-color"],
            .page-content [style*="background:"] {
                background: inherit !important;
            }
            
            /* ========== GENERAL SPACING ========== */
            /* Preserve general spacing between elements */
            .page-content * + * {
                margin-top: inherit !important;
            }
            
            /* Ensure section and article elements maintain their margins */
            .page-content div, 
            .page-content section, 
            .page-content article {
                margin-bottom: inherit !important;
                margin-top: inherit !important;
            }
            
            /* ========== PRINT SAFETY ========== */
            /* Ensure content doesn't get clipped or hidden */
            .page-content * {
                max-width: 100% !important;
                box-sizing: border-box !important;
                overflow: visible !important;
            }
            </style>
            `;
            
            // Insert the spacing preservation CSS right after the opening <head> tag or before closing </head>
            if (sanitized.includes('</head>')) {
                sanitized = sanitized.replace('</head>', spacingPreservationCSS + '</head>');
            } else if (sanitized.includes('<head>')) {
                sanitized = sanitized.replace('<head>', '<head>' + spacingPreservationCSS);
            } else {
                // If no head tag, add it at the beginning
                sanitized = spacingPreservationCSS + sanitized;
            }
            
            return sanitized;
        }

        // Recursively extract granular content for optimal space utilization
        function extractGranularContent(element, container, processedElements) {
            const elementKey = element.outerHTML;
            
            // Skip if already processed
            if (processedElements.has(elementKey)) {
                return;
            }
            
            // Content elements that should be kept as-is
            const contentTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'TABLE', 'UL', 'OL', 'BLOCKQUOTE', 'PRE', 'IMG', 'FIGURE'];
            
            // If this is a content element, add it directly
            if (contentTags.includes(element.tagName)) {
                container.appendChild(element.cloneNode(true));
                processedElements.add(elementKey);
                console.log(`Added content element: ${element.tagName}.${element.className || 'no-class'}`);
                return;
            }
            
            // For container elements, check if they should be broken down
            if (element.children.length > 0) {
                const hasMultipleContentChildren = Array.from(element.children).filter(child => 
                    contentTags.includes(child.tagName) || child.children.length > 0
                ).length > 1;
                
                if (hasMultipleContentChildren) {
                    // Break down container - extract children individually
                    Array.from(element.children).forEach(child => {
                        extractGranularContent(child, container, processedElements);
                    });
                    console.log(`Broke down container: ${element.tagName}.${element.className || 'no-class'} into ${element.children.length} children`);
                } else {
                    // Keep container as-is (single content item or styled element)
                    container.appendChild(element.cloneNode(true));
                    processedElements.add(elementKey);
                    console.log(`Kept container: ${element.tagName}.${element.className || 'no-class'}`);
                }
            } else if (element.textContent.trim()) {
                // Text content without children
                container.appendChild(element.cloneNode(true));
                processedElements.add(elementKey);
                console.log(`Added text element: ${element.tagName}.${element.className || 'no-class'}`);
            }
        }
        
        // Programmatically preserve visual fidelity by capturing and enforcing all computed styles
        function preserveVisualFidelity(container) {
            console.log('Preserving visual fidelity programmatically...');
            
            // Visual CSS properties that affect appearance but exclude layout-breaking ones
            const visualProperties = [
                // Typography
                'font-family', 'font-size', 'font-weight', 'font-style', 'font-variant',
                'line-height', 'letter-spacing', 'word-spacing', 'text-align', 'text-decoration',
                'text-transform', 'text-indent', 'text-shadow', 'font-stretch',
                
                // Colors & Backgrounds  
                'color', 'background-color', 'background-image', 'background-position', 
                'background-size', 'background-repeat', 'background-attachment', 'background-origin',
                'background-clip', 'background-blend-mode',
                
                // Borders & Outlines
                'border', 'border-color', 'border-style', 'border-width', 'border-radius',
                'border-top', 'border-right', 'border-bottom', 'border-left',
                'border-top-color', 'border-right-color', 'border-bottom-color', 'border-left-color',
                'border-top-style', 'border-right-style', 'border-bottom-style', 'border-left-style', 
                'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width',
                'border-top-left-radius', 'border-top-right-radius', 'border-bottom-right-radius', 'border-bottom-left-radius',
                'outline', 'outline-color', 'outline-style', 'outline-width', 'outline-offset',
                
                // Spacing (non-layout)
                'padding', 'padding-top', 'padding-right', 'padding-bottom', 'padding-left',
                'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left',
                
                // Visual Effects
                'box-shadow', 'text-shadow', 'opacity', 'filter', 'backdrop-filter',
                'transform', 'transform-origin', 'perspective', 'perspective-origin',
                
                // Table-specific
                'border-collapse', 'border-spacing', 'table-layout', 'empty-cells', 'caption-side',
                
                // Flexbox & Grid Visual Properties (not layout)
                'align-items', 'justify-content', 'align-content', 'align-self', 'justify-self',
                'gap', 'column-gap', 'row-gap',
                
                // List styling
                'list-style', 'list-style-type', 'list-style-position', 'list-style-image',
                
                // Visual display properties
                'visibility', 'text-overflow', 'white-space', 'word-wrap', 'word-break',
                'vertical-align'
            ];
            
            // Properties to explicitly exclude (layout/positioning that can break pagination)
            const excludeProperties = [
                'height', 'min-height', 'max-height', 'width', 'min-width', 'max-width',
                'position', 'top', 'right', 'bottom', 'left', 'z-index',
                'float', 'clear', 'flex', 'flex-grow', 'flex-shrink', 'flex-basis',
                'grid', 'grid-template', 'grid-area', 'order',
                'page-break-before', 'page-break-after', 'page-break-inside', 
                'break-before', 'break-after', 'break-inside',
                'overflow', 'overflow-x', 'overflow-y', // Exclude overflow properties that can break layout
                'display' // Exclude display to prevent layout breaking - we'll handle this specially
            ];
            
            let dynamicCSS = '';
            let processedElements = 0;
            
            // Get all elements in the container
            const allElements = container.querySelectorAll('*');
            
            allElements.forEach((element, index) => {
                try {
                    const computedStyles = window.getComputedStyle(element);
                    const tagName = element.tagName.toLowerCase();
                    
                    // Create a unique selector for this element type
                    let selector = `.page-content ${tagName}`;
                    if (element.className) {
                        // Handle multiple classes properly (e.g., "callout note" becomes ".callout.note")
                        const classes = element.className.split(' ').filter(cls => cls.trim());
                        if (classes.length > 0) {
                            selector += '.' + classes.join('.');
                        }
                    }
                    
                    let elementStyles = [];
                    
                    // Extract all visual properties that have non-default values
                    visualProperties.forEach(prop => {
                        const value = computedStyles.getPropertyValue(prop);
                        if (value && value !== 'none' && value !== 'auto' && value !== 'normal' && value !== 'initial') {
                            // Skip properties that are clearly defaults or might break layout
                            if (!excludeProperties.includes(prop)) {
                                elementStyles.push(`${prop}: ${value} !important`);
                            }
                        }
                    });
                    
                    // Handle display property selectively - only preserve safe display values
                    const displayValue = computedStyles.getPropertyValue('display');
                    if (displayValue && ['block', 'inline', 'inline-block', 'table', 'table-row', 'table-cell', 'table-header-group', 'table-row-group'].includes(displayValue)) {
                        elementStyles.push(`display: ${displayValue} !important`);
                    }
                    
                    // Special handling for table elements to preserve structure and rounded corners
                    if (tagName === 'table') {
                        elementStyles.push('border-collapse: separate !important');
                        elementStyles.push('border-spacing: 0 !important');
                        
                        // Aggressive border-radius preservation for tables
                        let borderRadius = computedStyles.getPropertyValue('border-radius');
                        
                        // If computed style shows 0px, check for CSS custom property (cloud.html uses --table-radius: 8px)
                        if (!borderRadius || borderRadius === '0px' || borderRadius === 'none') {
                            // Check if element has border-radius in inline styles or class styles
                            const inlineRadius = element.style.borderRadius;
                            if (inlineRadius && inlineRadius !== '0px') {
                                borderRadius = inlineRadius;
                            } else {
                                // For cloud.html, force 8px border-radius based on CSS custom property
                                borderRadius = '8px';
                            }
                        }
                        
                        if (borderRadius && borderRadius !== '0px' && borderRadius !== 'none') {
                            elementStyles.push(`border-radius: ${borderRadius} !important`);
                            elementStyles.push('overflow: hidden !important');
                            console.log(`Applied table border-radius: ${borderRadius}`);
                        }
                    }
                    
                    // Ensure table cells DON'T have border-radius (table container handles clipping)
                    if (tagName === 'th' || tagName === 'td') {
                        elementStyles.push('border-radius: 0 !important');
                    }
                    
                    // Special handling for fact nuggets (callout.note) to ensure blue styling
                    if (element.classList && element.classList.contains('callout') && element.classList.contains('note')) {
                        elementStyles.push('border-left-color: #4a90e2 !important');
                        elementStyles.push('background: #f0f7ff !important');
                        console.log('Applied special fact nugget styling');
                    }
                    
                    // Special handling for warning callouts
                    if (element.classList && element.classList.contains('callout') && element.classList.contains('warning')) {
                        elementStyles.push('border-left-color: #ff6b35 !important');
                        elementStyles.push('background: #fff3f0 !important');
                    }
                    
                    // Default callout styling
                    if (element.classList && element.classList.contains('callout') && !element.classList.contains('note') && !element.classList.contains('warning')) {
                        elementStyles.push('border-left: 4px solid #ccc !important');
                        elementStyles.push('background: #f8f8f8 !important');
                        elementStyles.push('padding: 10px 15px !important');
                        elementStyles.push('margin: 15px 0 !important');
                    }
                    
                    // Add styles to dynamic CSS if we found any (preserve DOM order for cascade)
                    if (elementStyles.length > 0) {
                        // Add element index to maintain CSS cascade order
                        const orderComment = `/* Element ${index + 1}: ${tagName}${element.className ? '.' + element.className.split(' ').join('.') : ''} */\n`;
                        dynamicCSS += orderComment + `${selector} {\n    ${elementStyles.join(';\n    ')};\n}\n\n`;
                        processedElements++;
                    }
                    
                } catch (error) {
                    console.warn(`Error processing element ${index}:`, error);
                }
            });
            
            console.log(`Processed ${processedElements} elements for visual fidelity preservation`);
            
            // Inject the dynamic CSS into the container
            if (dynamicCSS) {
                const styleElement = document.createElement('style');
                styleElement.textContent = `
/* ========== DYNAMIC VISUAL FIDELITY PRESERVATION ========== */
/* Auto-generated styles to preserve exact visual appearance */

${dynamicCSS}

/* ========== END DYNAMIC STYLES ========== */
                `;
                
                // Add to container's head or create one
                const head = container.querySelector('head') || document.head;
                if (head) {
                    head.appendChild(styleElement);
                } else {
                    container.insertBefore(styleElement, container.firstChild);
                }
                
                console.log(`Injected ${dynamicCSS.split('\n').length} lines of dynamic CSS`);
            }
            
            return container;
        }
        
        // Extract and normalize content - preserve individual elements AND styling
        function extractContent(htmlContent) {
            console.log('Extracting and normalizing content...');
            
            // Create a temporary container to parse the HTML
            const tempContainer = document.createElement('div');
            tempContainer.innerHTML = htmlContent;
            
            // Extract and preserve style tags
            const styleTags = Array.from(tempContainer.querySelectorAll('style'));
            preservedStyles = styleTags.map(style => style.outerHTML).join('\n'); // Store globally
            
            // Remove script tags for security and functionality
            const scripts = tempContainer.querySelectorAll('script');
            scripts.forEach(script => script.remove());
            
            // Get the body content, or the entire content if no body tag
            let content = tempContainer.querySelector('body') || tempContainer;
            
            // FLATTEN EXISTING PAGE STRUCTURE - remove .page containers but preserve layout hierarchy
            const pageContainers = content.querySelectorAll('.page');
            if (pageContainers.length > 0) {
                console.log(`Found pre-paginated structure with ${pageContainers.length} pages - flattening while preserving layout...`);
                
                // Smart flattening: preserve important layout containers while removing page wrappers
                const flattenedContent = document.createElement('div');
                const processedElements = new Set();
                
                pageContainers.forEach((pageContainer, pageIndex) => {
                    console.log(`Processing page ${pageIndex + 1} of ${pageContainers.length}`);
                    
                    // Get all direct children of the page container
                    const directChildren = Array.from(pageContainer.children);
                    
                    directChildren.forEach((child, childIndex) => {
                        // Skip page metadata elements
                        if (child.classList.contains('page-number') || 
                            child.classList.contains('report-footer') ||
                            child.classList.contains('page-header')) {
                            return;
                        }
                        
                        const childKey = child.outerHTML;
                        
                        // Skip if already processed
                        if (processedElements.has(childKey)) {
                            return;
                        }
                        
                        // Preserve layout containers like .two-column (with ALL nested content), .text-box, etc.
                        if (child.classList.contains('two-column') ||
                            child.classList.contains('text-box') ||
                            child.classList.contains('report-header') ||
                            child.tagName === 'SECTION' ||
                            child.tagName === 'ARTICLE' ||
                            (child.tagName === 'DIV' && child.children.length > 0 && 
                             (child.style.display === 'flex' || 
                              child.style.display === 'grid' ||
                              child.className.includes('container') ||
                              child.className.includes('row') ||
                              child.className.includes('layout')))) {
                            
                            // Keep the entire container structure intact with ALL nested content
                            flattenedContent.appendChild(child.cloneNode(true));
                            processedElements.add(childKey);
                            console.log(`Preserved complete layout container: ${child.tagName}.${child.className || 'no-class'} from page ${pageIndex + 1}`);
                            
                            // Also mark all nested elements as processed to avoid duplicates
                            const allNested = child.querySelectorAll('*');
                            allNested.forEach(nested => {
                                processedElements.add(nested.outerHTML);
                            });
                        }
                        // For content elements, add them directly
                        else if (['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'TABLE', 'UL', 'OL', 'BLOCKQUOTE', 'PRE', 'IMG', 'FIGURE'].includes(child.tagName)) {
                            flattenedContent.appendChild(child.cloneNode(true));
                            processedElements.add(childKey);
                            console.log(`Added content element: ${child.tagName}.${child.className || 'no-class'} from page ${pageIndex + 1}`);
                        }
                        // For other divs, check if they contain meaningful content
                        else if (child.tagName === 'DIV' && child.textContent.trim()) {
                            // If it's a simple content div, preserve it
                            flattenedContent.appendChild(child.cloneNode(true));
                            processedElements.add(childKey);
                            console.log(`Added content div: ${child.className || 'no-class'} from page ${pageIndex + 1}`);
                        }
                    });
                });
                
                content = flattenedContent;
                console.log(`Smart flattening complete - extracted ${flattenedContent.children.length} elements while preserving layout hierarchy`);
            }
            
            // Return content as-is without adding extra containers that cause visual artifacts
            let finalHTML = '';
            
            // Add preserved styles first
            if (preservedStyles) {
                finalHTML += preservedStyles;
            }
            
            // Add each content element individually to preserve structure
            Array.from(content.children).forEach(child => {
                // Skip head elements and other non-content elements
                if (!['SCRIPT', 'STYLE', 'META', 'TITLE', 'HEAD', 'LINK'].includes(child.tagName)) {
                    finalHTML += child.outerHTML;
                }
            });
            
            return finalHTML;
        }

        // Update workflow step visual indicators and button states
        function updateWorkflowStep(step, status) {
            const stepElement = document.getElementById(`step${step}`);
            const step3aElement = document.getElementById('step3a');
            const step3bElement = document.getElementById('step3b');
            
            if (step === 1) {
                stepElement.className = status === 'completed' ? 'workflow-step completed' : 
                                       status === 'active' ? 'workflow-step active' : 'workflow-step';
                
                // Enable/disable paginate button
                document.getElementById('paginateBtn').disabled = status !== 'completed';
            } else if (step === 2) {
                stepElement.className = status === 'completed' ? 'workflow-step completed' : 
                                       status === 'active' ? 'workflow-step active' : 'workflow-step';
                
                // Enable/disable print and download buttons
                const enableButtons = status === 'completed';
                document.getElementById('printBtn').disabled = !enableButtons;
                document.getElementById('downloadBtn').disabled = !enableButtons;
                
                // Update step 3 indicators
                if (enableButtons) {
                    step3aElement.className = 'workflow-step active';
                    step3bElement.className = 'workflow-step active';
                } else {
                    step3aElement.className = 'workflow-step';
                    step3bElement.className = 'workflow-step';
                }
            }
        }

        // Process HTML input - just clean and show original
        async function processHTML() {
            try {
                const htmlInput = uploadedHTMLContent.trim();
                
                if (!htmlInput) {
                    updateStatus('Please upload an HTML file first', 'error');
                    return;
                }
                
                updateStatus('Processing and cleaning HTML...');
                
                // Step 1: Sanitize CSS
                const sanitizedHTML = sanitizeCSS(htmlInput);
                
                // Step 2: Extract and normalize content
                const normalizedContent = extractContent(sanitizedHTML);
                
                // Step 3: Create temporary container for style analysis
                const tempContainer = document.createElement('div');
                tempContainer.innerHTML = sanitizedHTML;
                
                // Step 4: Preserve visual fidelity programmatically
                preserveVisualFidelity(tempContainer);
                
                // Step 5: Store processed content for display
                originalHTML = normalizedContent;
                document.getElementById('sourceContent').innerHTML = originalHTML;
                
                // Step 4: Prepare for measurement (but don't paginate yet)
                await measureElements(normalizedContent);
                
                // Update workflow: Step 1 completed, enable Step 2
                updateWorkflowStep(1, 'completed');
                updateWorkflowStep(2, 'active');
                document.getElementById('paginateBtn').disabled = false;
                
                // Show processed content
                const sourceContent = document.getElementById('sourceContent');
                const paginatedContent = document.getElementById('paginatedContent');
                sourceContent.style.display = 'block';
                paginatedContent.style.display = 'none';
                updateStatus('HTML processed and cleaned! Ready for pagination.', 'success');
                
            } catch (error) {
                console.error('Error processing HTML:', error);
                updateStatus('Error processing HTML: ' + error.message, 'error');
            }
        }

        // Smart HTML structure analysis - understand containers vs content
        function analyzeHTMLStructure(element) {
            const contentElements = [];
            
            // Define what we consider "content containers" vs "layout containers"
            const contentTags = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'TABLE', 'UL', 'OL', 'BLOCKQUOTE', 'PRE', 'IMG', 'FIGURE'];
            const layoutContainers = ['DIV', 'SECTION', 'ARTICLE', 'MAIN', 'HEADER', 'FOOTER', 'ASIDE'];
            
            // Special classes that should NEVER be split across pages
            const indivisibleClasses = ['callout', 'warning', 'success', 'info', 'alert', 'card', 'box'];
            
            function traverseElement(el) {
                const tagName = el.tagName;
                const hasIndivisibleClass = indivisibleClasses.some(cls => el.classList.contains(cls));
                
                // Check if this element should be treated as indivisible
                if (hasIndivisibleClass) {
                    // Callout boxes and similar styled containers must not be split
                    contentElements.push({
                        element: el,
                        height: el.offsetHeight,
                        type: 'indivisible-content'
                    });
                    return; // Don't traverse children - treat as single unit
                }
                
                if (contentTags.includes(tagName)) {
                    // This is actual content - add it for measurement
                    if (tagName === 'TABLE') {
                        // Smart table handling - check if table should be treated as unit or split
                        const tableHeight = el.offsetHeight;
                        const maxTableHeight = 800; // Tables larger than this should be split
                        
                        if (tableHeight <= maxTableHeight) {
                            // Small/medium table - treat as indivisible unit
                            contentElements.push({
                                element: el,
                                height: tableHeight,
                                type: 'indivisible-content' // This prevents splitting
                            });
                        } else {
                            // Large table - extract rows for flexible pagination
                            const tbody = el.querySelector('tbody');
                            if (tbody) {
                                const rows = Array.from(tbody.querySelectorAll('tr'));
                                rows.forEach(row => {
                                    contentElements.push({
                                        element: row,
                                        height: row.offsetHeight,
                                        type: 'table-row',
                                        parentTable: el
                                    });
                                });
                            }
                        }
                    } else {
                        // Regular content element
                        contentElements.push({
                            element: el,
                            height: el.offsetHeight,
                            type: 'content'
                        });
                    }
                } else if (layoutContainers.includes(tagName)) {
                    // Check if this is a small styled container that should be treated as content
                    const computedStyle = window.getComputedStyle(el);
                    const hasVisualStyling = 
                        computedStyle.backgroundColor !== 'rgba(0, 0, 0, 0)' ||
                        computedStyle.borderRadius !== '0px' ||
                        computedStyle.backgroundImage !== 'none' ||
                        computedStyle.boxShadow !== 'none' ||
                        computedStyle.border !== '0px none rgb(51, 51, 51)' ||
                        el.style.background !== '';
                    
                    // Check if element has margins that suggest it's a spaced card
                    const marginBottom = parseFloat(computedStyle.marginBottom) || 0;
                    const marginTop = parseFloat(computedStyle.marginTop) || 0;
                    const hasSignificantMargins = marginBottom > 10 || marginTop > 10;
                    
                    // Only treat as content unit if it's small enough AND has visual styling OR significant margins
                    const elementHeight = el.offsetHeight;
                    const maxContentHeight = 400; // More conservative - only truly small elements should be indivisible
                    
                    // Be more selective about what we consider "indivisible"
                    const isSmallStyledElement = (hasVisualStyling || hasSignificantMargins) && elementHeight <= maxContentHeight;
                    const isCalloutOrCard = el.classList.contains('callout') || el.classList.contains('card') || el.classList.contains('note');
                    
                    if (isSmallStyledElement || (isCalloutOrCard && elementHeight <= 800)) {
                        // Small styled element or specific card types - treat as indivisible
                        contentElements.push({
                            element: el,
                            height: elementHeight,
                            type: 'indivisible-content'
                        });
                    } else {
                        // Large container or unstyled - traverse its children
                        Array.from(el.children).forEach(child => {
                            traverseElement(child);
                        });
                    }
                } else {
                    // Unknown element - treat as content if it has text/no children, container otherwise
                    if (el.children.length === 0 && el.textContent.trim()) {
                        // Text content
                        contentElements.push({
                            element: el,
                            height: el.offsetHeight,
                            type: 'content'
                        });
                    } else if (el.children.length > 0) {
                        // Has children - traverse
                        Array.from(el.children).forEach(child => {
                            traverseElement(child);
                        });
                    }
                }
            }
            
            traverseElement(element);
            return contentElements;
        }
        
        // Handle different content types with smart analysis
        function processContentByType(element) {
            return analyzeHTMLStructure(element);
        }

        // Enhanced measurement function with better accuracy and spacing preservation
        function getAccurateElementHeight(element) {
            // Create a temporary container that exactly matches our page styling
            const tempContainer = document.createElement('div');
            tempContainer.style.cssText = `
                position: absolute;
                top: -9999px;
                left: -9999px;
                visibility: hidden;
                width: 210mm;
                padding: 0.6cm;
                font-family: Helvetica, Arial, sans-serif;
                line-height: 1.4;
                font-size: 11pt;
                box-sizing: border-box;
            `;
            
            // Clone the element to avoid affecting the original
            const clonedElement = element.cloneNode(true);
            tempContainer.appendChild(clonedElement);
            document.body.appendChild(tempContainer);
            
            // Force layout calculation and wait for any images/fonts
            tempContainer.offsetHeight;
            
            // Get the accurate height including margins and borders
            const computedStyle = window.getComputedStyle(clonedElement);
            const marginTop = parseFloat(computedStyle.marginTop) || 0;
            const marginBottom = parseFloat(computedStyle.marginBottom) || 0;
            const paddingTop = parseFloat(computedStyle.paddingTop) || 0;
            const paddingBottom = parseFloat(computedStyle.paddingBottom) || 0;
            
            // Include full spacing in height calculation to preserve gaps between cards
            const actualHeight = clonedElement.offsetHeight + marginTop + marginBottom;
            
            // Clean up
            document.body.removeChild(tempContainer);
            
            // Reduced safety buffer for better space utilization
            const buffer = (clonedElement.tagName === 'TABLE' || 
                           clonedElement.classList.contains('two-column') ||
                           clonedElement.classList.contains('text-box') ||
                           clonedElement.classList.contains('stat-box')) ? 8 : 4; // Reduced buffer for better space usage
            
            console.log(`Element ${element.tagName}.${element.className || 'no-class'}: height=${clonedElement.offsetHeight}px, marginTop=${marginTop}px, marginBottom=${marginBottom}px, total=${actualHeight + buffer}px`);
            
            return Math.ceil(actualHeight) + buffer;
        }

        // Measure all elements in the content and add spacing between cards
        async function measureElements(content) {
            console.log('Starting enhanced element measurement...');
            
            const measurementContainer = document.getElementById('measurementContainer');
            measurementContainer.innerHTML = content;
            
            // Apply exact page styling to measurement container
            measurementContainer.style.cssText = `
                position: absolute;
                top: -9999px;
                left: -9999px;
                visibility: hidden;
                width: 210mm;
                padding: 0.6cm;
                font-family: Helvetica, Arial, sans-serif;
                line-height: 1.4;
                font-size: 11pt;
                box-sizing: border-box;
            `;
            
            // Force layout calculation
            measurementContainer.offsetHeight;
            
            // Get all top-level elements that should be measured individually
            // Handle both wrapped and unwrapped content
            let elements;
            if (measurementContainer.children.length === 1 && measurementContainer.children[0].children.length > 0) {
                // Content is wrapped in a container
                elements = Array.from(measurementContainer.children[0].children);
            } else {
                // Content is not wrapped or multiple top-level elements
                elements = Array.from(measurementContainer.children);
            }
            
            processedElements = [];
            elementHeights = [];
            
            console.log(`Total elements found: ${elements.length}`);
            console.log('Elements detected:', elements.map(el => `${el.tagName}.${el.className || 'no-class'}`));
            
            elements.forEach((element, index) => {
                const processedItems = processContentByType(element);
                
                processedItems.forEach((item, itemIndex) => {
                    // Use enhanced height measurement for better accuracy
                    const accurateHeight = getAccurateElementHeight(item.element);
                    item.height = accurateHeight;
                    
                    processedElements.push(item);
                    elementHeights.push(accurateHeight);
                    
                    console.log(`Enhanced measurement - Element ${index + 1}.${itemIndex + 1}: ${item.element.tagName}.${item.element.className || 'no-class'} - ${accurateHeight}px (Type: ${item.type})`);
                });
                
                // Add explicit spacing between elements (except after the last one)
                if (index < elements.length - 1) {
                    const currentStyle = window.getComputedStyle(element);
                    const nextElement = elements[index + 1];
                    const nextStyle = window.getComputedStyle(nextElement);
                    
                    const marginBottom = parseFloat(currentStyle.marginBottom) || 0;
                    const marginTop = parseFloat(nextStyle.marginTop) || 0;
                    
                    // Use margin collapse rules: max of the two margins
                    const spacing = Math.max(marginBottom, marginTop);
                    
                    if (spacing > 5) { // Only add spacing if there's a meaningful gap
                        const spacer = document.createElement('div');
                        spacer.style.height = spacing + 'px';
                        spacer.style.width = '100%';
                        spacer.style.backgroundColor = 'transparent';
                        spacer.className = 'spacing-element';
                        
                        const spacingItem = {
                            element: spacer,
                            height: spacing,
                            type: 'spacing'
                        };
                        
                        processedElements.push(spacingItem);
                        elementHeights.push(spacing);
                        
                        console.log(`Added spacing element: ${spacing}px between element ${index + 1} and ${index + 2}`);
                    }
                }
            });
            
            console.log(`Total elements measured (including spacing): ${processedElements.length}`);
            console.log('Height distribution:', elementHeights.sort((a, b) => b - a).slice(0, 10), '(top 10 largest)');
        }

        // Create a new page
        function createNewPage(pageNumber, needsTable = false, tableTemplate = null) {
            const page = document.createElement('div');
            page.className = 'page';
            
            const content = document.createElement('div');
            content.className = 'page-content';
            
            // Add data attribute to help with CSS targeting
            content.setAttribute('data-preserve-spacing', 'true');
            
            if (needsTable && tableTemplate) {
                // Create table with header for table rows - preserve all styling
                const table = tableTemplate.cloneNode(true);
                const tbody = table.querySelector('tbody');
                if (tbody) tbody.innerHTML = ''; // Clear body, keep header
                
                // Preserve the table container structure from original
                const tableContainer = document.createElement('div');
                tableContainer.className = 'table-container';
                tableContainer.appendChild(table);
                content.appendChild(tableContainer);
            }
            
            page.appendChild(content);
            document.getElementById('paginatedContent').appendChild(page);
            
            // Initialize page height tracking
            pageHeights.set(page, 0);
            
            return { page, content, table: needsTable ? content.querySelector('table') : null };
        }

        // Track cumulative height per page
        const pageHeights = new Map(); // page -> cumulative height
        
        // Enhanced function to preserve computed styles when cloning elements
        function cloneElementWithStyles(originalElement) {
            const clone = originalElement.cloneNode(true);
            const originalStyles = window.getComputedStyle(originalElement);
            
            // Visual properties that must be preserved to maintain fidelity
            const criticalVisualProps = [
                'font-family', 'font-size', 'font-weight', 'font-style', 'line-height', 
                'color', 'background-color', 'background-image', 'background', 
                'border', 'border-radius', 'border-color', 'border-style', 'border-width',
                'padding', 'margin', 'text-align', 'text-decoration', 'text-transform',
                'box-shadow', 'opacity', 'gap'
            ];
            
            // Properties to exclude from cloning to prevent layout issues
            const excludeFromCloning = [
                'position', 'top', 'right', 'bottom', 'left', 'z-index',
                'width', 'height', 'min-width', 'min-height', 'max-width', 'max-height',
                'overflow', 'overflow-x', 'overflow-y', 'display'
            ];
            
            // Apply all critical visual properties as inline styles to ensure they're preserved
            criticalVisualProps.forEach(prop => {
                if (!excludeFromCloning.includes(prop)) {
                    const value = originalStyles.getPropertyValue(prop);
                    if (value && value !== 'none' && value !== 'auto' && value !== 'normal' && value !== 'initial') {
                        clone.style.setProperty(prop, value, 'important');
                    }
                }
            });
            
            // Special handling for table border-radius preservation during cloning
            if (originalElement.tagName.toLowerCase() === 'table') {
                let borderRadius = originalStyles.getPropertyValue('border-radius');
                
                // Aggressive border-radius detection for cloud.html tables
                if (!borderRadius || borderRadius === '0px' || borderRadius === 'none') {
                    // Check inline styles first
                    const inlineRadius = originalElement.style.borderRadius;
                    if (inlineRadius && inlineRadius !== '0px') {
                        borderRadius = inlineRadius;
                    } else {
                        // Force 8px for cloud.html tables (from --table-radius CSS custom property)
                        borderRadius = '8px';
                    }
                }
                
                if (borderRadius && borderRadius !== '0px' && borderRadius !== 'none') {
                    clone.style.setProperty('border-radius', borderRadius, 'important');
                    clone.style.setProperty('overflow', 'hidden', 'important');
                    clone.style.setProperty('border-collapse', 'separate', 'important');
                    clone.style.setProperty('border-spacing', '0', 'important');
                    console.log(`Applied border-radius to cloned table: ${borderRadius}`);
                }
            }
            
            // Recursively apply styles to all child elements
            const originalChildren = originalElement.querySelectorAll('*');
            const clonedChildren = clone.querySelectorAll('*');
            
            originalChildren.forEach((child, index) => {
                if (clonedChildren[index]) {
                    const childStyles = window.getComputedStyle(child);
                    criticalVisualProps.forEach(prop => {
                        if (!excludeFromCloning.includes(prop)) {
                            const value = childStyles.getPropertyValue(prop);
                            if (value && value !== 'none' && value !== 'auto' && value !== 'normal' && value !== 'initial') {
                                clonedChildren[index].style.setProperty(prop, value, 'important');
                            }
                        }
                    });
                }
            });
            
            return clone;
        }
        
        // Legacy function - keeping for compatibility
        function cloneElementWithStylesLegacy(originalElement) {
            const clone = originalElement.cloneNode(true);
            const originalStyles = window.getComputedStyle(originalElement);
            
            // Preserve ALL spacing and visual properties to maintain exact appearance
            const importantProps = [
                'margin-top', 'margin-bottom', 'margin-left', 'margin-right',
                'padding-top', 'padding-bottom', 'padding-left', 'padding-right',
                'border-top', 'border-bottom', 'border-left', 'border-right',
                'background-color', 'background-image', 'background-size', 'background-position',
                'border-radius', 'box-shadow', 'display'
            ];
            
            importantProps.forEach(prop => {
                const value = originalStyles.getPropertyValue(prop);
                if (value && value !== 'initial' && value !== 'normal') {
                    clone.style.setProperty(prop, value, 'important');
                }
            });
            
            // Preserve class names which may contain styling
            clone.className = originalElement.className;
            
            // Copy any inline styles
            if (originalElement.style.cssText) {
                clone.style.cssText += '; ' + originalElement.style.cssText;
            }
            
            return clone;
        }
        
        // Measure remaining space in page - use cumulative approach  
        function getRemainingSpace(page) {
            // Enhanced space utilization - more aggressive page filling
            // A4 is 297mm height. At 96 DPI: 297mm = 1123px approximately
            const pageHeightPx = 1123;
            // Reduce padding for better space utilization (was 23*2 = 46px, now 18*2 = 36px)
            const paddingPx = 18 * 2; // More aggressive padding for better space usage
            const availableHeight = pageHeightPx - paddingPx;
            
            // Get cumulative height for this page
            const currentHeight = pageHeights.get(page) || 0;
            const remainingSpace = availableHeight - currentHeight;
            
            console.log(`Page height: ${pageHeightPx}px, Available: ${availableHeight}px, Current: ${currentHeight}px, Remaining: ${remainingSpace}px`);
            
            return remainingSpace;
        }
        
        // Add element height to page tracking
        function addElementHeightToPage(page, elementHeight) {
            const currentHeight = pageHeights.get(page) || 0;
            pageHeights.set(page, currentHeight + elementHeight);
        }

        // Real-time cumulative height measurement during pagination
        function measureCumulativeHeight(pageContent) {
            // Create temporary page container with exact styling
            const tempPage = document.createElement('div');
            tempPage.className = 'page';
            tempPage.style.cssText = `
                position: absolute;
                top: -9999px;
                left: -9999px;
                visibility: hidden;
                width: 210mm;
                min-height: auto;
                background: white;
                padding: 0.6cm;
                box-sizing: border-box;
                font-family: Helvetica, Arial, sans-serif;
                line-height: 1.4;
                font-size: 11pt;
            `;
            
            // Clone all current page content
            const tempContent = document.createElement('div');
            tempContent.className = 'page-content';
            Array.from(pageContent.children).forEach(child => {
                tempContent.appendChild(child.cloneNode(true));
            });
            
            tempPage.appendChild(tempContent);
            document.body.appendChild(tempPage);
            
            // Force layout and measure - be more thorough
            tempPage.offsetHeight; // Force layout
            tempContent.offsetHeight; // Force content layout
            
            // Use the larger of scrollHeight and offsetHeight to ensure we capture all content
            const scrollHeight = tempContent.scrollHeight;
            const offsetHeight = tempContent.offsetHeight;
            const actualHeight = Math.max(scrollHeight, offsetHeight);
            
            console.log(`Height measurement: scrollHeight=${scrollHeight}, offsetHeight=${offsetHeight}, using=${actualHeight}`);
            
            // Cleanup
            document.body.removeChild(tempPage);
            
            return actualHeight;
        }

        // Main pagination logic - using real-time measurement
        async function paginateContent() {
            if (!processedElements.length) {
                updateStatus('Please process HTML first before paginating', 'error');
                return;
            }
            
            console.log('Starting real-time measurement pagination...');
            updateStatus('Creating paginated layout with accurate measurements...');
            
            // Clear existing paginated content and add preserved styles
            const paginatedContent = document.getElementById('paginatedContent');
            paginatedContent.innerHTML = '';
            
            // Add preserved styles to ensure proper styling in paginated content
            if (preservedStyles) {
                paginatedContent.insertAdjacentHTML('afterbegin', preservedStyles);
            }
            
            
            
            let currentElementIndex = 0;
            let pageNumber = 1;
            let { page, content } = createNewPage(pageNumber);
            let table = null;
            
            let totalElementsPlaced = 0;
            let pagesCreated = 1;
            
            // A4 available height calculation with proper margins: 
            // Total A4 height: 297mm = 1122px at 96 DPI
            // Top + Bottom padding: 0.6cm + 0.6cm = 1.2cm = 45.35px at 96 DPI  
            // Available content height: 1122px - 45px = 1077px
            // Enhanced space utilization - use more of the available space
            const maxPageHeight = 1100; // Even more aggressive to fill empty spaces (was 1050px)
            
            while (currentElementIndex < processedElements.length) {
                const currentItem = processedElements[currentElementIndex];
                
                console.log(`Attempting to place element ${currentElementIndex + 1}: ${currentItem.element.tagName}.${currentItem.element.className || 'no-class'} (${currentItem.type})`);
                
                // Create a temporary copy of what the page would look like with this element
                let testContent = content.cloneNode(true);
                let testTable = null;
                
                // Simulate adding the element
                if (currentItem.type === 'table-row') {
                    if (!table) {
                        // Need to create table structure
                        const tableContainer = document.createElement('div');
                        tableContainer.className = 'table-container';
                        
                        const newTable = currentItem.parentTable.cloneNode(false);
                        const thead = currentItem.parentTable.querySelector('thead');
                        if (thead) {
                            newTable.appendChild(cloneElementWithStyles(thead));
                        }
                        const tbody = document.createElement('tbody');
                        newTable.appendChild(tbody);
                        
                        tableContainer.appendChild(newTable);
                        testContent.appendChild(tableContainer);
                        testTable = newTable;
                    } else {
                        testTable = testContent.querySelector('table:last-of-type');
                    }
                    
                    const tbody = testTable ? testTable.querySelector('tbody') : null;
                    if (tbody) {
                        tbody.appendChild(cloneElementWithStyles(currentItem.element));
                    }
                } else if (currentItem.type === 'spacing') {
                    // Spacing element - add directly with style preservation
                    testContent.appendChild(cloneElementWithStyles(currentItem.element));
                    testTable = null;
                } else if (currentItem.type === 'indivisible-content') {
                    // Indivisible content (including complete tables, callouts, cards, etc.)
                    const clonedElement = cloneElementWithStyles(currentItem.element);
                    testContent.appendChild(clonedElement);
                    testTable = null;
                } else {
                    // Regular element
                    const clonedElement = cloneElementWithStyles(currentItem.element);
                    testContent.appendChild(clonedElement);
                    testTable = null;
                }
                
                // Measure the height with this element added
                const heightWithElement = measureCumulativeHeight(testContent);
                
                console.log(`Test height with element: ${heightWithElement}px, Max: ${maxPageHeight}px`);
                
                if (heightWithElement <= maxPageHeight) {
                    // Element fits! Actually add it to the page
                    if (currentItem.type === 'table-row') {
                        if (!table) {
                            const tableContainer = document.createElement('div');
                            tableContainer.className = 'table-container';
                            
                            table = currentItem.parentTable.cloneNode(false);
                            const thead = currentItem.parentTable.querySelector('thead');
                            if (thead) {
                                table.appendChild(cloneElementWithStyles(thead));
                            }
                            const tbody = document.createElement('tbody');
                            table.appendChild(tbody);
                            
                            tableContainer.appendChild(table);
                            content.appendChild(tableContainer);
                        }
                        const tbody = table.querySelector('tbody');
                        if (tbody) {
                            tbody.appendChild(cloneElementWithStyles(currentItem.element));
                        }
                    } else if (currentItem.type === 'spacing') {
                        // Spacing element - add directly to preserve gaps between cards
                        content.appendChild(cloneElementWithStyles(currentItem.element));
                        table = null; // Reset table context
                    } else if (currentItem.type === 'indivisible-content') {
                        // Indivisible content (complete tables, callouts, cards, styled boxes)
                        const clonedElement = cloneElementWithStyles(currentItem.element);
                        content.appendChild(clonedElement);
                        table = null; // Reset table context for non-table content
                    } else {
                        // Regular element
                        const clonedElement = cloneElementWithStyles(currentItem.element);
                        content.appendChild(clonedElement);
                        table = null; // Reset table context for non-table content
                    }
                    
                    totalElementsPlaced++;
                    currentElementIndex++;
                    
                    console.log(`✓ Element placed. Page ${pageNumber} content height: ${heightWithElement}px`);
                } else {
                    // Element doesn't fit - before creating new page, try to fill remaining space with smaller elements
                    console.log(`✗ Element would exceed page height (${heightWithElement}px > ${maxPageHeight}px). Looking for smaller elements to fill remaining space.`);
                    
                    // Check if element is too large for any page
                    if (heightWithElement > maxPageHeight * 2) {
                        console.log(`⚠️ Element is extremely large (${heightWithElement}px). Skipping to avoid infinite loops.`);
                        currentElementIndex++;
                        continue;
                    }
                    
                    // Look-ahead: try to find smaller elements that can fit in remaining space
                    // But be conservative when we're in the middle of table processing to preserve CSS order
                    let foundSmallerElement = false;
                    let lookaheadIndex = currentElementIndex + 1;
                    
                    // Check if we're currently processing table content - be more specific about table context
                    let isTableContext = (currentItem.type === 'table-row') || 
                                        (currentItem.type === 'indivisible-content' && currentItem.element.tagName && currentItem.element.tagName.toLowerCase() === 'table');
                    
                    // Only skip look-ahead if we're actively processing table rows, not just because a table exists
                    if (!isTableContext) {
                        while (lookaheadIndex < processedElements.length && !foundSmallerElement) {
                            const lookaheadItem = processedElements[lookaheadIndex];
                            
                            // Skip table rows and indivisible content for look-ahead (too complex to reorder)
                            if (lookaheadItem.type === 'table-row' || lookaheadItem.type === 'indivisible-content') {
                                lookaheadIndex++;
                                continue;
                            }
                        
                        // Test if this smaller element would fit
                        let testContentLookahead = content.cloneNode(true);
                        const clonedLookaheadElement = cloneElementWithStyles(lookaheadItem.element);
                        testContentLookahead.appendChild(clonedLookaheadElement);
                        
                        const heightWithLookaheadElement = measureCumulativeHeight(testContentLookahead);
                        
                        if (heightWithLookaheadElement <= maxPageHeight) {
                            // Found a smaller element that fits! Place it now
                            console.log(`✓ Found smaller element that fits: ${lookaheadItem.element.tagName}.${lookaheadItem.element.className || 'no-class'} (${heightWithLookaheadElement}px)`);
                            
                            content.appendChild(clonedLookaheadElement);
                            totalElementsPlaced++;
                            
                            // Remove the lookahead element from the queue
                            processedElements.splice(lookaheadIndex, 1);
                            foundSmallerElement = true;
                            
                            // Continue with current element (don't increment currentElementIndex)
                            break;
                        } else {
                            lookaheadIndex++;
                        }
                        
                            // Limit look-ahead to prevent performance issues
                            if (lookaheadIndex > currentElementIndex + 10) {
                                break;
                            }
                        }
                    }
                    
                    // If no smaller elements found or we've exhausted look-ahead, create new page
                    if (!foundSmallerElement) {
                        console.log(`No smaller elements found. Creating new page for: ${currentItem.element.tagName}.${currentItem.element.className || 'no-class'}`);
                        
                        pageNumber++;
                        pagesCreated++;
                        const needsTable = currentItem.type === 'table-row';
                        const newPageData = createNewPage(pageNumber, needsTable, currentItem.parentTable);
                        page = newPageData.page;
                        content = newPageData.content;
                        table = newPageData.table;
                        
                        // Don't increment currentElementIndex - try the same element on the new page
                    }
                }
                
                // Safety check to prevent infinite loops
                if (pagesCreated > 200) {
                    console.error('Safety limit reached - stopping pagination');
                    break;
                }
            }
            
            console.log(`Real-time pagination complete: ${totalElementsPlaced} elements placed across ${pagesCreated} pages`);
            
            showPaginated();
            
            // Apply programmatic visual fidelity preservation to final paginated content
            updateStatus('Applying visual fidelity preservation...');
            const paginatedContainer = document.getElementById('paginatedContent');
            preserveVisualFidelity(paginatedContainer);
            
            // Update workflow: Step 2 completed, enable Step 3 (Print/Download)
            updateWorkflowStep(2, 'completed');
            
            updateStatus(`Pagination complete! Created ${pagesCreated} pages with ${totalElementsPlaced} elements using real-time measurement and programmatic style preservation.`, 'success');
        }

        // Download PDF using jsPDF - direct PDF generation
        async function downloadPDF() {
            const paginatedContent = document.getElementById('paginatedContent');
            if (!paginatedContent.children.length) {
                alert('Please paginate the content first before downloading PDF.');
                return;
            }
            
            updateStatus('Generating PDF directly from your perfect layout... This may take a moment.');
            
            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                
                const pages = Array.from(paginatedContent.querySelectorAll('.page'));
                let pageIndex = 0;
                
                for (const page of pages) {
                    updateStatus(`Processing page ${pageIndex + 1} of ${pages.length}...`);
                    
                    // If not the first page, add a new page
                    if (pageIndex > 0) {
                        pdf.addPage();
                    }
                    
                    try {
                        // Convert page to canvas with balanced quality/size settings
                        const canvas = await html2canvas(page, {
                            scale: 1.8, // Increased for better quality (was 1.5)
                            useCORS: true,
                            allowTaint: true,
                            backgroundColor: '#ffffff',
                            width: page.offsetWidth,
                            height: page.offsetHeight,
                            scrollX: 0,
                            scrollY: 0,
                            removeContainer: true, // Clean up temporary elements
                            imageTimeout: 0 // Skip problematic images
                        });
                        
                        // Calculate dimensions to fit A4 (210 x 297mm)
                        // Use JPEG with higher quality for better text clarity
                        const imgData = canvas.toDataURL('image/jpeg', 0.92); // Increased to 92% quality
                        const imgWidth = 210; // A4 width in mm
                        const imgHeight = 297; // A4 height in mm
                        
                        // Add image to PDF with JPEG compression
                        pdf.addImage(imgData, 'JPEG', 0, 0, imgWidth, imgHeight);
                        
                    } catch (pageError) {
                        console.error(`Error processing page ${pageIndex + 1}:`, pageError);
                        updateStatus(`Warning: Issue with page ${pageIndex + 1}, continuing...`, 'error');
                    }
                    
                    pageIndex++;
                }
                
                // Generate filename with timestamp
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const filename = `paginated-document-${timestamp}.pdf`;
                
                // Get PDF size for reporting
                const pdfOutput = pdf.output('blob');
                const fileSizeMB = (pdfOutput.size / (1024 * 1024)).toFixed(2);
                
                // Save the PDF
                pdf.save(filename);
                
                updateStatus(`✅ PDF generated successfully! Downloaded "${filename}" (${fileSizeMB} MB, ${pages.length} pages)`, 'success');
                
            } catch (error) {
                console.error('Direct PDF generation error:', error);
                updateStatus('Error generating PDF directly. Please try the regular Print button.', 'error');
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
    </div>
</body>
</html>