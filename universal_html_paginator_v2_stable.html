<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal HTML to Print Paginator v2</title>
    <!-- jsPDF and html2canvas for direct PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* Print styles */
        @page {
            size: A4;
            margin: 0;
        }

        @media print {
            /* ULTIMATE OVERRIDE: Reset everything for absolute print control */
            *, *::before, *::after {
                -webkit-print-color-adjust: exact !important;
                color-adjust: exact !important;
                box-sizing: border-box !important;
            }
            
            html, body {
                margin: 0 !important;
                padding: 0 !important;
                background: white !important;
                max-width: none !important;
                overflow: visible !important;
                height: auto !important;
                min-height: auto !important;
            }
            
            /* ABSOLUTE PAGE CONTROL: Force Chrome to treat each page as a separate print page */
            .page {
                page-break-after: always !important;
                page-break-before: auto !important;
                page-break-inside: avoid !important;
                break-after: page !important;
                break-before: auto !important;
                break-inside: avoid-page !important;
                margin: 0 !important;
                padding: 0.6cm !important;
                box-shadow: none !important;
                border: none !important;
                background: white !important;
                width: 210mm !important;
                height: 297mm !important;
                max-height: 297mm !important;
                min-height: 297mm !important;
                display: block !important;
                overflow: hidden !important;
                position: relative !important;
                contain: layout style paint size !important;
                isolation: isolate !important;
            }
            
            .page:last-child {
                page-break-after: auto !important;
                break-after: auto !important;
            }
            
            /* ATOMIC CONTENT: Make page content indivisible */
            .page-content {
                page-break-inside: avoid !important;
                break-inside: avoid-page !important;
                height: auto !important;
                max-height: 285.4mm !important;
                overflow: visible !important;
                display: block !important;
                contain: layout style !important;
            }
            
            /* NUCLEAR OVERRIDE: Every element within pages is indivisible */
            .page *, .page *::before, .page *::after {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                page-break-before: auto !important;
                break-before: auto !important;
                page-break-after: auto !important;
                break-after: auto !important;
            }
            
            /* MAXIMUM TABLE PROTECTION */
            table, caption, thead, tbody, tfoot, tr, th, td {
                page-break-inside: avoid !important;
                break-inside: avoid-page !important;
                page-break-before: auto !important;
                break-before: auto !important;
                page-break-after: auto !important;
                break-after: auto !important;
                overflow: visible !important;
                contain: none !important;
            }
            
            /* STYLED CONTAINER ABSOLUTE PROTECTION */
            .callout, [class*="callout"], .warning, .success, .info, .alert, .card, .box,
            div[style*="background"], div[style*="border"], div[style*="box-shadow"],
            div[style*="padding"], div[style*="margin"] {
                page-break-inside: avoid !important;
                break-inside: avoid-page !important;
                display: block !important;
                overflow: visible !important;
                contain: none !important;
            }
            
            /* HEADING COHESION */
            h1, h2, h3, h4, h5, h6 {
                page-break-after: avoid !important;
                break-after: avoid !important;
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                keep-with-next: always !important;
                contain: none !important;
            }
            
            /* TEXT FLOW CONTROL */
            p, ul, ol, li, blockquote, div, span {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                orphans: 4 !important;
                widows: 4 !important;
                contain: none !important;
            }
            
            /* HIDE NON-PRINT ELEMENTS */
            .controls, .file-input, .source-content, .status, .debug-info, .measurement-container {
                display: none !important;
                visibility: hidden !important;
            }
            
            /* FORCE PAGINATED CONTENT VISIBILITY */
            .paginated-content {
                display: block !important;
                visibility: visible !important;
                position: static !important;
                contain: none !important;
            }
            
            /* CHROME HACK: Force physical page dimensions */
            @page {
                size: A4 !important;
                margin: 0 !important;
                padding: 0 !important;
            }
        }

        /* General styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Helvetica, Arial, sans-serif;
            background: white;
            padding: 20px;
            line-height: 1.4;
            width: 100%;
            height: auto; /* Allow dynamic height expansion */
            min-height: 100vh;
        }
        
        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            height: auto; /* Allow dynamic height expansion */
            background: white;
        }

        /* Page container for screen view */
        .page {
            width: 210mm;
            min-height: 297mm;
            background: white;
            margin: 0 auto 20px auto;
            padding: 0.6cm;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #ccc;
            position: relative;
            page-break-after: always;
        }

        /* Page content area - Let JavaScript handle height constraints */
        .page-content {
            /* No height constraints - pure JavaScript pagination logic */
        }

        /* Controls */
        .controls {
            text-align: center;
            margin: 0 auto 30px auto;
            background: #f8f8f8;
            padding: 25px;
            border-radius: 12px;
            border: 2px solid #000;
            color: black;
            width: 800px;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .controls h2 {
            margin: 0 0 20px 0;
            font-size: 24px;
            font-weight: bold;
            font-family: Helvetica, Arial, sans-serif;
            color: black;
        }

        .controls button {
            padding: 10px 14px;
            margin: 0;
            border: 2px solid #000;
            background: #f0f8ff;
            color: black;
            cursor: pointer;
            border-radius: 8px;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
        }
        
        /* Download Dropdown Styles */
        .download-dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 280px;
            background: white;
            border: 2px solid #000;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            overflow: hidden;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s ease;
            font-size: 14px;
            line-height: 1.2;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background-color: #f0f8ff;
        }

        .dropdown-item small {
            display: block;
            color: #666;
            font-size: 11px;
            margin-top: 2px;
        }

        .button-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            flex-wrap: nowrap;
            margin-bottom: 20px;
        }
        
        .button-row button {
            flex: 0 0 auto;
        }

        .controls button:hover {
            background: #e0f0ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .controls button:disabled {
            background: #ccc !important;
            color: #666 !important;
            cursor: not-allowed !important;
            opacity: 0.6 !important;
            transform: none !important;
            box-shadow: none !important;
        }

        .controls button:disabled:hover {
            background: #ccc !important;
            transform: none !important;
            box-shadow: none !important;
        }
        
        /* Workflow step indicators */
        .workflow-step {
            display: inline-block;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #ccc;
            color: white;
            text-align: center;
            line-height: 24px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        .workflow-step.completed {
            background: #4CAF50;
        }
        
        .workflow-step.active {
            background: #2196F3;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .controls button.primary {
            background: #4CAF50;
            color: white;
            border-color: #000;
        }

        .controls button.primary:hover {
            background: #45a049;
        }

        /* File input area */
        .file-input {
            background: #fffef7;
            border: 2px solid #000;
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            margin: 20px 0;
            font-family: Helvetica, Arial, sans-serif;
        }

        .file-input:hover {
            background: #fff8e1;
        }

        .file-input.dragover {
            border-color: #4CAF50;
            background: #f9f9f9;
        }

        .upload-button {
            margin: 15px 0;
            padding: 12px 30px;
            border: 2px solid #000;
            border-radius: 25px;
            background: #f0f8ff;
            color: black;
            font-family: Helvetica, Arial, sans-serif;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .upload-button:hover {
            background: #e0f0ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .html-input {
            width: 100%;
            height: 200px;
            margin: 10px 0;
            padding: 15px;
            border: 2px solid #000;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            font-weight: normal;
            background: #f8fff8;
            resize: vertical;
        }
        
        .html-input:focus {
            outline: none;
            background: #f0fff0;
        }

        /* Source content (shown initially) */
        .source-content {
            display: block;
            width: 800px;
            max-width: 100%;
            height: auto; /* Allow full height expansion */
            min-height: auto; /* Remove height constraints */
            margin: 0 auto 20px auto;
            background: white;
            padding: 0.6cm;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #ccc;
            box-sizing: border-box;
            overflow: visible; /* Ensure content is not clipped */
        }

        /* Styling for extracted page content */
        .source-content .extracted-page-content {
            display: block;
            width: 100%;
            margin-bottom: 20px;
            line-height: 1.45;
            color: #111;
        }
        
        .source-content .extracted-page-content > * {
            margin-bottom: 12px;
        }
        
        .source-content .extracted-page-content table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            border: 1px solid #000;
            border-radius: 8px;
            overflow: hidden;
            background: #fff;
            margin: 15px 0;
        }
        
        .source-content .extracted-page-content thead {
            display: table-header-group;
        }
        
        .source-content .extracted-page-content thead th {
            background: #fafafa;
            font-weight: bold;
        }
        
        .source-content .extracted-page-content tbody {
            display: table-row-group;
        }
        
        .source-content .extracted-page-content th,
        .source-content .extracted-page-content td {
            padding: 8px 10px;
            border-right: 1px solid #000;
            border-bottom: 1px solid #000;
            vertical-align: top;
            text-align: left;
        }
        
        .source-content .extracted-page-content th:last-child,
        .source-content .extracted-page-content td:last-child {
            border-right: none;
        }
        
        .source-content .extracted-page-content tbody tr:last-child td {
            border-bottom: none;
        }
        
        /* PRESERVE alternating row colors from original cloud.html */\n        .source-content .extracted-page-content tbody tr:nth-child(even) td,\n        .page-content table tbody tr:nth-child(even) td {
            background: #f5f5f5 !important; /* Force alternating row colors */
        }
        
        .source-content .extracted-page-content .callout {
            border-left: 4px solid #ccc;
            padding: 10px 15px;
            margin: 15px 0;
            background: #f8f8f8;
        }
        
        .source-content .extracted-page-content .callout.warning {
            border-left-color: #ff6b35;
            background: #fff3f0;
        }
        
        .source-content .extracted-page-content .callout.note {
            border-left-color: #4a90e2;
            background: #f0f7ff;
        }
        
        .source-content .extracted-page-content .meta {
            color: #666;
            font-size: 0.9em;
        }
        
        .source-content .extracted-page-content h1,
        .source-content .extracted-page-content h2,
        .source-content .extracted-page-content h3,
        .source-content .extracted-page-content h4,
        .source-content .extracted-page-content h5,
        .source-content .extracted-page-content h6 {
            font-weight: bold;
            margin: 0 0 12px 0;
        }
        
        .source-content .extracted-page-content p,
        .source-content .extracted-page-content ul,
        .source-content .extracted-page-content ol {
            margin: 0 0 12px 0;
        }
        
        /* Paginated content container */
        .paginated-content {
            margin: 0 auto;
            max-width: 1200px;
        }

        /* Ensure content fits properly within page bounds */
        .source-content *,
        .page-content * {
            max-width: 100%;
            box-sizing: border-box;
        }

        /* Status and debug info */
        .status {
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
            color: #666;
            display: none !important; /* Hide status messages from display */
        }


        /* Measurement container (hidden) */
        .measurement-container {
            position: absolute;
            top: -9999px;
            left: -9999px;
            visibility: hidden;
            width: 210mm;
            padding: 0.6cm;
        }
    </style>
</head>
<body>
    <div class="main-container">
    <div class="controls">
        <h2>Universal HTML to Print Paginator v2</h2>
        <p>Transform any HTML content into perfectly paginated A4 print layouts</p>
        
        <div class="file-input" id="fileInput">
            <p style="margin-bottom: 15px;"><strong>Method 1:</strong> Upload HTML File</p>
            <input type="file" accept=".html,.htm" id="htmlFile" style="display: none;">
            <button class="upload-button" onclick="document.getElementById('htmlFile').click()">📁 Choose HTML File</button>
        </div>
        
        <div class="button-row">
            <button onclick="processHTML()" id="processBtn" class="primary">
                <span class="workflow-step active" id="step1">1</span>✨ Process HTML
            </button>
            
            <button onclick="paginateContent()" id="paginateBtn" disabled>
                <span class="workflow-step" id="step2">2</span>📖 Paginate
            </button>
            
            <button onclick="printPaginated()" id="printBtn" disabled>
                <span class="workflow-step" id="step3a">3</span>🖨️ Print
            </button>
            
            <div class="download-dropdown" id="downloadDropdown">
                <button id="downloadBtn" disabled style="background: #e74c3c; border-color: #000;" onclick="toggleDownloadMenu()">
                    <span class="workflow-step" id="step3b">3</span>📥 Download ▼
                </button>
                <div class="dropdown-menu" id="downloadMenu">
                    <div class="dropdown-item" onclick="downloadProcessedHTML()">
                        📄 Download Processed HTML
                        <small>Exact as rendered on screen</small>
                    </div>
                    <div class="dropdown-item" onclick="downloadPaginatedHTML()">
                        📖 Download Paginated HTML
                        <small>All pages as single HTML file</small>
                    </div>
                    <div class="dropdown-item" onclick="console.log('PDF dropdown clicked'); downloadPDF();">
                        📄 Download High-Quality PDF
                        <small>Faithful reproduction of pages</small>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 15px; padding: 12px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; font-size: 13px; color: #856404;">
            <strong>📋 Print Settings:</strong> For perfect results, set Chrome print margins to <strong>"None"</strong> (not Default). Keep scale at 100% and paper size as A4. <br>
            <strong>💡 Best Quality:</strong> Use <strong>"Download PDF"</strong> for direct PDF generation that captures your perfect pagination exactly as shown on screen!
        </div>
    </div>

    <div class="status" id="status" style="display: none !important; visibility: hidden !important;">Ready - Upload HTML file or paste content above</div>
    

    <!-- Hidden measurement container -->
    <div class="measurement-container" id="measurementContainer">
        <!-- Cloned content for measurement will go here -->
    </div>

    <!-- Source content container -->
    <div class="source-content" id="sourceContent" style="display: none;">
        <!-- Original content will be displayed here -->
    </div>

    <!-- Paginated content container -->
    <div class="paginated-content" id="paginatedContent">
        <!-- Paginated pages will be generated here -->
    </div>

    <script>
        let originalHTML = '';
        let processedElements = [];
        let elementHeights = [];
        let preservedStyles = ''; // Store extracted styles globally
        let uploadedHTMLContent = ''; // Store uploaded HTML content
        let originalFileName = ''; // Store original filename for downloads
        let isPDFGenerating = false; // Prevent concurrent PDF downloads

        // Download dropdown toggle function
        function toggleDownloadMenu() {
            const menu = document.getElementById('downloadMenu');
            menu.classList.toggle('show');
            
            // Close dropdown when clicking outside
            if (menu.classList.contains('show')) {
                document.addEventListener('click', closeDropdownOnOutsideClick);
            }
        }

        function closeDropdownOnOutsideClick(event) {
            const dropdown = document.getElementById('downloadDropdown');
            if (!dropdown.contains(event.target)) {
                document.getElementById('downloadMenu').classList.remove('show');
                document.removeEventListener('click', closeDropdownOnOutsideClick);
            }
        }

        // Download Processed HTML as exact rendered version
        async function downloadProcessedHTML() {
            const sourceContent = document.getElementById('sourceContent');
            if (!sourceContent || !sourceContent.innerHTML.trim()) {
                alert('Please process HTML content first before downloading.');
                return;
            }

            updateStatus('Preparing processed HTML for download...');

            try {
                // Temporarily show the source content to ensure proper extraction
                const originalDisplay = sourceContent.style.display;
                sourceContent.style.display = 'block';
                
                // Create complete HTML document
                const htmlContent = createCompleteHTMLDocument(sourceContent, 'Processed Document');
                
                // Restore original display state
                sourceContent.style.display = originalDisplay;
                
                // Create download
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                
                const baseFileName = originalFileName || 'document';
                a.href = url;
                a.download = `${baseFileName}_processed.html`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                updateStatus('✅ Processed HTML downloaded successfully!', 'success');
                
            } catch (error) {
                console.error('Error downloading processed HTML:', error);
                updateStatus('Error downloading processed HTML.', 'error');
            }
            
            // Close dropdown
            document.getElementById('downloadMenu').classList.remove('show');
        }

        // Download Paginated HTML as complete document
        async function downloadPaginatedHTML() {
            const paginatedContent = document.getElementById('paginatedContent');
            if (!paginatedContent.children.length) {
                alert('Please paginate the content first before downloading.');
                return;
            }

            updateStatus('Preparing paginated HTML for download...');

            try {
                // Create complete HTML document with all pages
                const htmlContent = createCompleteHTMLDocument(paginatedContent, 'Paginated Document');
                
                // Create download
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                
                const baseFileName = originalFileName || 'document';
                const pageCount = paginatedContent.children.length;
                a.href = url;
                a.download = `${baseFileName}_paginated.html`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                updateStatus(`✅ Paginated HTML downloaded successfully! (${pageCount} pages)`, 'success');
                
            } catch (error) {
                console.error('Error downloading paginated HTML:', error);
                updateStatus('Error downloading paginated HTML.', 'error');
            }
            
            // Close dropdown
            document.getElementById('downloadMenu').classList.remove('show');
        }

        // Helper function to create complete HTML document with embedded styles
        function createCompleteHTMLDocument(contentElement, title) {
            // Extract all stylesheets from the current page
            const stylesheets = Array.from(document.querySelectorAll('style, link[rel="stylesheet"]'))
                .map(el => {
                    if (el.tagName === 'STYLE') {
                        return el.outerHTML;
                    } else {
                        // For external stylesheets, we'll need to inline them
                        return `<style>/* External stylesheet: ${el.href} */</style>`;
                    }
                }).join('\n        ');

            // Get the content HTML
            const contentHTML = contentElement.outerHTML;

            // Create complete document
            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    ${stylesheets}
</head>
<body>
    ${contentHTML}
    <script>
        // Simple script to handle print functionality if needed
        function printDocument() {
            window.print();
        }
    <\/script>
</body>
</html>`;
        }

        // Initialize the application
        function init() {
            console.log('Universal HTML Paginator v2 initialized');
            
            // Force hide status element to prevent console output display
            const statusElement = document.getElementById('status');
            if (statusElement) {
                statusElement.style.display = 'none';
                statusElement.style.visibility = 'hidden';
                statusElement.style.position = 'absolute';
                statusElement.style.top = '-9999px';
            }
            
            // Initialize workflow states - only step 1 is active, others disabled
            document.getElementById('step1').className = 'workflow-step active';
            document.getElementById('step2').className = 'workflow-step';
            document.getElementById('step3a').className = 'workflow-step';
            document.getElementById('step3b').className = 'workflow-step';
            
            // Initial button states
            document.getElementById('processBtn').disabled = false;
            document.getElementById('paginateBtn').disabled = true;
            document.getElementById('printBtn').disabled = true;
            document.getElementById('downloadBtn').disabled = true;
            
            // Set up file input handlers
            const fileInput = document.getElementById('htmlFile');
            const fileInputArea = document.getElementById('fileInput');
            
            fileInput.addEventListener('change', handleFileSelect);
            
            // Set up drag and drop
            fileInputArea.addEventListener('dragover', handleDragOver);
            fileInputArea.addEventListener('drop', handleDrop);
            fileInputArea.addEventListener('dragenter', (e) => {
                e.preventDefault();
                fileInputArea.classList.add('dragover');
            });
            fileInputArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                fileInputArea.classList.remove('dragover');
            });
        }

        // Handle file selection
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && (file.type === 'text/html' || file.name.endsWith('.html') || file.name.endsWith('.htm'))) {
                // Store original filename (without extension) for downloads
                originalFileName = file.name.replace(/\.(html|htm)$/i, '');
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    uploadedHTMLContent = e.target.result;
                    updateStatus('HTML file loaded successfully');
                    
                    // Reset button states for new file upload - allow fresh processing cycle
                    document.getElementById('paginateBtn').disabled = true; // Will be enabled after processing
                };
                reader.readAsText(file);
            } else {
                updateStatus('Please select a valid HTML file', 'error');
            }
        }

        // Handle drag and drop
        function handleDragOver(event) {
            event.preventDefault();
        }

        function handleDrop(event) {
            event.preventDefault();
            document.getElementById('fileInput').classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'text/html' || file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                    // Store original filename (without extension) for downloads
                    originalFileName = file.name.replace(/\.(html|htm)$/i, '');
                    
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        uploadedHTMLContent = e.target.result;
                        updateStatus('HTML file dropped and loaded successfully');
                        
                        // Reset button states for new file upload - allow fresh processing cycle
                        document.getElementById('paginateBtn').disabled = true; // Will be enabled after processing
                    };
                    reader.readAsText(file);
                } else {
                    updateStatus('Please drop a valid HTML file', 'error');
                }
            }
        }

        // Update status message
        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            if (status) {
                status.textContent = message;
                status.style.color = type === 'error' ? '#d32f2f' : type === 'success' ? '#388e3c' : '#666';
                status.style.display = 'none'; // Force hide status messages
                status.style.visibility = 'hidden'; // Double ensure it's hidden
            }
            // For debugging, log to console instead of showing on page
            console.log(`[Status] ${message}`);
        }


        // Print paginated content only
        function printPaginated() {
            // Ensure paginated content is visible
            document.getElementById('sourceContent').style.display = 'none';
            document.getElementById('paginatedContent').style.display = 'block';
            
            // Check if we have paginated content
            const paginatedContent = document.getElementById('paginatedContent');
            if (!paginatedContent.children.length) {
                alert('Please paginate the content first before printing.');
                return;
            }
            
            updateStatus('Preparing paginated content for print...');
            // Print
            window.print();
        }


        // Show paginated content
        function showPaginated() {
            document.getElementById('sourceContent').style.display = 'none';
            document.getElementById('paginatedContent').style.display = 'block';
            updateStatus('Showing paginated content');
        }

        // CSS Sanitization Engine - remove pagination-breaking rules
        function sanitizeCSS(htmlContent) {
            console.log('Starting CSS sanitization...');
            
            // MINIMAL sanitization - preserve 100% visual fidelity
            // Only remove CSS rules that actually break pagination flow
            const problematicRules = [
                /page-break-[^;]*;/gi,
                /break-[^;]*;/gi,
                /@page[^}]*}/gi,
                /height:\s*100vh[^;]*;/gi,          // Remove viewport heights  
                /min-height:\s*100vh[^;]*;/gi,
                /height:\s*100%[^;]*;/gi,           // Remove 100% heights that cause issues
                /min-height:\s*100%[^;]*;/gi,
                /\.page-content\s*\{[^}]*overflow:\s*hidden[^}]*\}/gi,  // Remove overflow:hidden ONLY from page-content
                /height:\s*calc\([^)]*\)[^;]*;/gi,  // Remove calc() heights that constrain flow
                /max-height:\s*[^;]*vh[^;]*;/gi,    // Remove viewport-based max heights
                /width:\s*793px[^;]*;/gi,           // Remove hardcoded 793px width that breaks layout
                /body\s*\{[^}]*background[^}]*\}/gi // Remove body background that might cause artifacts
            ];
            
            let sanitized = htmlContent;
            problematicRules.forEach(rule => {
                sanitized = sanitized.replace(rule, '');
            });
            
            // Comprehensive CSS fixes for all common HTML document formatting issues
            const spacingPreservationCSS = `
            <style>
            /* ========== LIST FORMATTING ========== */
            ul, ol {
                padding-left: 2.5em !important;
            }
            
            /* ========== SPACING PRESERVATION ========== */
            /* Preserve spacing and styling for specific content elements */
            .page-content .stat-box,
            .source-content .stat-box {
                margin: 8pt 0 !important;
                background-color: #00CCCC !important; /* Ensure cyan background is preserved */
                color: white !important;
                padding: 10pt !important;
                border-radius: 4pt !important;
                text-align: center !important;
                font-weight: bold !important;
            }
            
            /* CRITICAL: Preserve table header colors from original HTML */
            .page-content th,
            .source-content th {
                /* Match original cloud.html styling - light gray headers */
                background-color: #fafafa !important;
                color: #111 !important;
                font-weight: bold !important;
            }
            .page-content .text-box {
                margin: 12pt 0 !important;
            }
            .page-content .callout {
                margin: 15px 0 !important;
                padding: 10px 15px !important;
            }
            
            /* Preserve spacing between paragraphs and special elements */
            .page-content p + .text-box,
            .page-content p + .callout,
            .page-content p + .stat-box {
                margin-top: 12pt !important;
            }
            .page-content .text-box + p,
            .page-content .callout + p,
            .page-content .stat-box + p {
                margin-top: 12pt !important;
            }
            .page-content p + p {
                margin-top: 1em !important;
            }
            
            /* Heading spacing */
            .page-content h1, .page-content h2, .page-content h3, .page-content h4, .page-content h5, .page-content h6 {
                margin-top: 1.5em !important;
                margin-bottom: 0.5em !important;
                color: inherit !important;
            }
            .page-content h1:first-child, .page-content h2:first-child, .page-content h3:first-child {
                margin-top: 0 !important;
            }
            
            /* ========== PROGRAMMATIC STYLE PRESERVATION PLACEHOLDER ========== */
            /* Styles will be dynamically generated by preserveVisualFidelity() function */
            /* This ensures 100% visual fidelity without hardcoding document-specific rules */
            
            /* ========== VISUAL FIDELITY PRESERVATION ========== */
            /* CRITICAL FIX: Preserve ALL visual styling - NO overlay removal that breaks design */
            
            /* CRITICAL FIX: Force table styling preservation */
            .page-content table,
            .source-content table {
                /* Force preserve original styling - no inheritance issues */
                border-collapse: separate !important;
                border-spacing: 0 !important;
                border-radius: 8px !important; /* Force rounded corners */
                overflow: hidden !important; /* Clip content to rounded corners */
                border: 1px solid #000 !important; /* Force table border */
                width: 100% !important;
                margin: 15px 0 !important;
            }
            
            /* CRITICAL: Force GRAY table headers to match original cloud.html */
            .page-content table thead th,
            .source-content table thead th,
            .page-content table th,
            .source-content table th {
                background: #fafafa !important; /* Original light gray header from cloud.html */
                color: #111 !important; /* Dark text on light gray background */
                font-weight: bold !important;
                padding: 8px 10px !important;
                border-right: 1px solid #000 !important;
                border-bottom: 1px solid #000 !important;
                text-align: left !important;
            }
            
            /* Force table cell styling */
            .page-content table td,
            .source-content table td {
                padding: 8px 10px !important;
                border-right: 1px solid #000 !important;
                border-bottom: 1px solid #000 !important;
                vertical-align: top !important;
                text-align: left !important;
                background: white !important;
            }
            
            /* Remove borders on last column and last row */
            .page-content table th:last-child,
            .page-content table td:last-child,
            .source-content table th:last-child,
            .source-content table td:last-child {
                border-right: none !important;
            }
            
            .page-content table tbody tr:last-child td,
            .source-content table tbody tr:last-child td {
                border-bottom: none !important;
            }
            
            /* PRESERVE table container styling completely */
            .page-content .table-container,
            .source-content .table-container {
                /* Keep ALL original styling - no transparency overrides */
                background: inherit !important;
                border-radius: inherit !important;
                box-shadow: inherit !important;
                padding: inherit !important;
                margin: inherit !important;
            }
            
            /* PRESERVE all visual containers - NO background removal */
            .page-content .container,
            .page-content div[class*="container"],
            .source-content .container,
            .source-content div[class*="container"] {
                /* Preserve ALL styling - no transparency overrides that break visual design */
                background: inherit !important;
                border-radius: inherit !important;
                box-shadow: inherit !important;
                border: inherit !important;
            }
            
            /* Preserve margins for styled elements */
            .page-content div[style*="margin"] {
                margin: inherit !important;
            }
            .page-content div[class*="card"] {
                margin: inherit !important;
            }
            .page-content div[class*="container"] {
                margin: inherit !important;
            }
            .page-content div[style*="background"] {
                margin: inherit !important;
            }
            .page-content div[style*="border"] {
                margin: inherit !important;
            }
            
            /* ========== TEXT AND COLOR FIXES ========== */
            /* Ensure text remains visible */
            .page-content p, .page-content li, .page-content span {
                color: inherit !important;
            }
            
            /* Link styling preservation */
            .page-content a {
                color: #3498db !important;
                text-decoration: none !important;
            }
            .page-content a:hover {
                text-decoration: underline !important;
            }
            
            /* ========== BACKGROUND FIXES ========== */
            /* Remove problematic backgrounds that cause artifacts */
            .page-content body {
                background: transparent !important;
            }
            .page-content html {
                background: transparent !important;
            }
            
            /* Preserve intended backgrounds for content elements */
            .page-content .stat-box,
            .page-content .text-box,
            .page-content .callout,
            .page-content .reference-box,
            .page-content [class*="box"],
            .page-content [style*="background-color"],
            .page-content [style*="background:"] {
                background: inherit !important;
            }
            
            /* ========== GENERAL SPACING ========== */
            /* Preserve general spacing between elements */
            .page-content * + * {
                margin-top: inherit !important;
            }
            
            /* Ensure section and article elements maintain their margins */
            .page-content div, 
            .page-content section, 
            .page-content article {
                margin-bottom: inherit !important;
                margin-top: inherit !important;
            }
            
            /* ========== PRINT SAFETY ========== */
            /* Ensure content doesn't get clipped or hidden */
            .page-content * {
                max-width: 100% !important;
                box-sizing: border-box !important;
                overflow: visible !important;
            }
            
            /* ========== SOURCE CONTENT SCROLLABILITY FIXES ========== */
            /* TARGETED fix for scrollability - preserve 100% visual fidelity */
            /* Only override constraints that prevent scrolling in source view */
            
            .source-content {
                height: auto !important;
                min-height: auto !important;
                max-height: none !important;
                overflow: visible !important;
                /* SURGICAL FIX: Ensure perfect centering for both cloud.html and ml.html */
                display: block !important;
                margin: 0 auto 20px auto !important;
                width: 800px !important;
                max-width: 100% !important;
                position: relative !important;
                left: auto !important;
                right: auto !important;
            }
            
            /* Allow fixed-height documents to scroll in source view while preserving visuals */
            .source-content .page {
                height: auto !important;
                min-height: auto !important;
                max-height: none !important;
                overflow: visible !important;
            }
            
            /* Allow absolute-positioned content to flow naturally in source view */
            .source-content .page-content {
                height: auto !important;
                min-height: auto !important;
                max-height: none !important;
                overflow: visible !important;
            }
            
            /* ========== PAGINATED CONTENT PAGE SEPARATION ========== */
            /* CLEAN fix: Subtle page separation without background overlay */
            .paginated-content {
                padding: 20px 0 !important; /* Vertical padding for spacing */
                min-height: 100vh !important; /* Full viewport height */
            }
            
            .paginated-content .page {
                width: 210mm !important;
                min-height: 297mm !important; /* Allow content to expand beyond if needed */
                margin-bottom: 30px !important; /* Increased gap for cleaner separation */
                box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important; /* Subtle shadow */
                border: 1px solid #ddd !important; /* Very subtle border */
                margin-left: auto !important; /* Ensure centering */
                margin-right: auto !important; /* Ensure centering */
                padding: 0.6cm !important;
                box-sizing: border-box !important;
                background: white !important;
                overflow: visible !important; /* Allow content to be visible, not cut off */
                display: block !important; /* Ensure block display */
                border-radius: 4px !important; /* Minimal rounded corners */
            }
            
            /* ========== CONTENT DISPLAY TOGGLE ========== */
            /* Ensure proper switching between processed and paginated content */
            .source-content[style*="display: none"] {
                display: none !important;
                visibility: hidden !important;
                height: 0 !important;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            .paginated-content[style*="display: block"] {
                display: block !important;
                visibility: visible !important;
            }
            
            .paginated-content[style*="display: none"] {
                display: none !important;
                visibility: hidden !important;
                height: 0 !important;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            /* ========== PRESERVE 100% VISUAL FIDELITY ========== */
            /* Remove any overrides that interfere with original styling */
            /* Let the original CSS handle all colors, backgrounds, fonts */
            </style>
            `;
            
            // Insert the spacing preservation CSS right after the opening <head> tag or before closing </head>
            if (sanitized.includes('</head>')) {
                sanitized = sanitized.replace('</head>', spacingPreservationCSS + '</head>');
            } else if (sanitized.includes('<head>')) {
                sanitized = sanitized.replace('<head>', '<head>' + spacingPreservationCSS);
            } else {
                // If no head tag, add it at the beginning
                sanitized = spacingPreservationCSS + sanitized;
            }
            
            return sanitized;
        }

        // Recursively extract granular content for optimal space utilization
        function extractGranularContent(element, container, processedElements) {
            const elementKey = element.outerHTML;
            
            // Skip if already processed
            if (processedElements.has(elementKey)) {
                return;
            }
            
            // Content elements that should be kept as-is
            const contentTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'TABLE', 'UL', 'OL', 'BLOCKQUOTE', 'PRE', 'IMG', 'FIGURE'];
            
            // If this is a content element, add it directly
            if (contentTags.includes(element.tagName)) {
                container.appendChild(element.cloneNode(true));
                processedElements.add(elementKey);
                console.log(`Added content element: ${element.tagName}.${element.className || 'no-class'}`);
                return;
            }
            
            // For container elements, check if they should be broken down
            if (element.children.length > 0) {
                const hasMultipleContentChildren = Array.from(element.children).filter(child => 
                    contentTags.includes(child.tagName) || child.children.length > 0
                ).length > 1;
                
                if (hasMultipleContentChildren) {
                    // Break down container - extract children individually
                    Array.from(element.children).forEach(child => {
                        extractGranularContent(child, container, processedElements);
                    });
                    console.log(`Broke down container: ${element.tagName}.${element.className || 'no-class'} into ${element.children.length} children`);
                } else {
                    // Keep container as-is (single content item or styled element)
                    container.appendChild(element.cloneNode(true));
                    processedElements.add(elementKey);
                    console.log(`Kept container: ${element.tagName}.${element.className || 'no-class'}`);
                }
            } else if (element.textContent.trim()) {
                // Text content without children
                container.appendChild(element.cloneNode(true));
                processedElements.add(elementKey);
                console.log(`Added text element: ${element.tagName}.${element.className || 'no-class'}`);
            }
        }
        
        // Programmatically preserve visual fidelity by capturing and enforcing all computed styles
        function preserveVisualFidelity(container) {
            console.log('Preserving original CSS without modifications...');
            
            // MINIMAL APPROACH: Only remove pagination-breaking CSS, let original CSS handle visuals
            // The original HTML already has perfect visual styles - don't recreate them!
            
            // Add only minimal pagination cleanup CSS
            const cleanupCSS = `
/* ========== MINIMAL PAGINATION CLEANUP ========== */
/* Remove ONLY pagination artifacts - preserve all original visual styling */

* {
    page-break-before: auto !important;
    page-break-after: auto !important; 
    page-break-inside: auto !important;
    break-before: auto !important;
    break-after: auto !important;
    break-inside: auto !important;
}

/* Remove fixed heights that break content flow - EXCEPT for paginated view */
.source-content .page, .page-content {
    height: auto !important;
    min-height: auto !important;
    max-height: none !important;
}

/* VIEWPORT APPROACH: Minimal styling for viewport pages */
.viewport-page {
    /* Just basic A4 page styling - no visual interference */
    page-break-after: always;
    margin: 0;
    padding: 0;
}

.viewport-content {
    /* Minimal container - let original CSS handle all visuals */
    margin: 0;
    padding: 0;
    /* Ensure content flows naturally within A4 constraints */
    width: 100%;
    height: auto;
}

/* ========== END MINIMAL CLEANUP ========== */
            `;
            
            // Inject ONLY the minimal cleanup CSS - trust the original CSS for all visuals
            const styleElement = document.createElement('style');
            styleElement.textContent = cleanupCSS;
            
            const head = container.querySelector('head') || document.head;
            if (head) {
                head.appendChild(styleElement);
            } else {
                container.insertBefore(styleElement, container.firstChild);
            }
            
            console.log('Applied minimal pagination cleanup - trusting original CSS for all visuals');
            
            return container;
        }
        
        // Extract and normalize content - preserve individual elements AND styling
        function extractContent(htmlContent) {
            console.log('Extracting and normalizing content...');
            
            // Create a temporary container to parse the HTML
            const tempContainer = document.createElement('div');
            tempContainer.innerHTML = htmlContent;
            
            // Extract and preserve style tags
            const styleTags = Array.from(tempContainer.querySelectorAll('style'));
            preservedStyles = styleTags.map(style => style.outerHTML).join('\n'); // Store globally
            
            // Remove script tags for security and functionality
            const scripts = tempContainer.querySelectorAll('script');
            scripts.forEach(script => script.remove());
            
            // Get the body content, or the entire content if no body tag
            let content = tempContainer.querySelector('body') || tempContainer;
            
            // FLATTEN EXISTING PAGE STRUCTURE - remove .page containers but preserve layout hierarchy
            const pageContainers = content.querySelectorAll('.page');
            if (pageContainers.length > 0) {
                console.log(`Found pre-paginated structure with ${pageContainers.length} pages - flattening while preserving layout...`);
                
                // Smart flattening: preserve important layout containers while removing page wrappers
                const flattenedContent = document.createElement('div');
                const processedElements = new Set();
                
                pageContainers.forEach((pageContainer, pageIndex) => {
                    console.log(`Processing page ${pageIndex + 1} of ${pageContainers.length}`);
                    
                    // Get all direct children of the page container
                    const directChildren = Array.from(pageContainer.children);
                    
                    directChildren.forEach((child, childIndex) => {
                        // Skip page metadata elements
                        if (child.classList.contains('page-number') || 
                            child.classList.contains('report-footer') ||
                            child.classList.contains('page-header')) {
                            return;
                        }
                        
                        const childKey = child.outerHTML;
                        
                        // Skip if already processed
                        if (processedElements.has(childKey)) {
                            return;
                        }
                        
                        // Preserve layout containers like .two-column (with ALL nested content), .text-box, etc.
                        if (child.classList.contains('two-column') ||
                            child.classList.contains('text-box') ||
                            child.classList.contains('report-header') ||
                            child.tagName === 'SECTION' ||
                            child.tagName === 'ARTICLE' ||
                            (child.tagName === 'DIV' && child.children.length > 0 && 
                             (child.style.display === 'flex' || 
                              child.style.display === 'grid' ||
                              child.className.includes('container') ||
                              child.className.includes('row') ||
                              child.className.includes('layout')))) {
                            
                            // Keep the entire container structure intact with ALL nested content
                            flattenedContent.appendChild(child.cloneNode(true));
                            processedElements.add(childKey);
                            console.log(`Preserved complete layout container: ${child.tagName}.${child.className || 'no-class'} from page ${pageIndex + 1}`);
                            
                            // Also mark all nested elements as processed to avoid duplicates
                            const allNested = child.querySelectorAll('*');
                            allNested.forEach(nested => {
                                processedElements.add(nested.outerHTML);
                            });
                        }
                        // For content elements, add them directly
                        else if (['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'TABLE', 'UL', 'OL', 'BLOCKQUOTE', 'PRE', 'IMG', 'FIGURE'].includes(child.tagName)) {
                            flattenedContent.appendChild(child.cloneNode(true));
                            processedElements.add(childKey);
                            console.log(`Added content element: ${child.tagName}.${child.className || 'no-class'} from page ${pageIndex + 1}`);
                        }
                        // For other divs, check if they contain meaningful content
                        else if (child.tagName === 'DIV' && child.textContent.trim()) {
                            // Special handling for .page-content divs - extract their children but preserve context
                            if (child.classList.contains('page-content')) {
                                // Create a wrapper div to maintain styling context
                                const wrapper = document.createElement('div');
                                wrapper.className = 'extracted-page-content';
                                
                                Array.from(child.children).forEach(innerChild => {
                                    wrapper.appendChild(innerChild.cloneNode(true));
                                    console.log(`Added content from .page-content: ${innerChild.tagName}.${innerChild.className || 'no-class'} from page ${pageIndex + 1}`);
                                });
                                
                                flattenedContent.appendChild(wrapper);
                                processedElements.add(childKey);
                            } else {
                                // If it's a simple content div, preserve it
                                flattenedContent.appendChild(child.cloneNode(true));
                                processedElements.add(childKey);
                                console.log(`Added content div: ${child.className || 'no-class'} from page ${pageIndex + 1}`);
                            }
                        }
                    });
                });
                
                content = flattenedContent;
                console.log(`Smart flattening complete - extracted ${flattenedContent.children.length} elements while preserving layout hierarchy`);
            }
            
            // Return content as-is without adding extra containers that cause visual artifacts
            let finalHTML = '';
            
            // Add preserved styles first
            if (preservedStyles) {
                finalHTML += preservedStyles;
            }
            
            // Add each content element individually to preserve structure
            Array.from(content.children).forEach(child => {
                // Skip head elements and other non-content elements
                if (!['SCRIPT', 'STYLE', 'META', 'TITLE', 'HEAD', 'LINK'].includes(child.tagName)) {
                    finalHTML += child.outerHTML;
                }
            });
            
            return finalHTML;
        }

        // Update workflow step visual indicators and button states
        function updateWorkflowStep(step, status) {
            const stepElement = document.getElementById(`step${step}`);
            const step3aElement = document.getElementById('step3a');
            const step3bElement = document.getElementById('step3b');
            
            if (step === 1) {
                stepElement.className = status === 'completed' ? 'workflow-step completed' : 
                                       status === 'active' ? 'workflow-step active' : 'workflow-step';
                
                // Enable/disable paginate button
                document.getElementById('paginateBtn').disabled = status !== 'completed';
            } else if (step === 2) {
                stepElement.className = status === 'completed' ? 'workflow-step completed' : 
                                       status === 'active' ? 'workflow-step active' : 'workflow-step';
                
                // Enable/disable print and download buttons
                const enableButtons = status === 'completed';
                document.getElementById('printBtn').disabled = !enableButtons;
                document.getElementById('downloadBtn').disabled = !enableButtons;
                
                // Update step 3 indicators
                if (enableButtons) {
                    step3aElement.className = 'workflow-step active';
                    step3bElement.className = 'workflow-step active';
                } else {
                    step3aElement.className = 'workflow-step';
                    step3bElement.className = 'workflow-step';
                }
            }
        }

        // Process HTML input - just clean and show original
        async function processHTML() {
            try {
                const htmlInput = uploadedHTMLContent.trim();
                
                if (!htmlInput) {
                    updateStatus('Please upload an HTML file first', 'error');
                    return;
                }
                
                updateStatus('Processing and cleaning HTML...');
                
                // Step 1: Sanitize CSS
                const sanitizedHTML = sanitizeCSS(htmlInput);
                
                // Step 2: Extract and normalize content
                const normalizedContent = extractContent(sanitizedHTML);
                
                // Step 3: Store processed content for display first
                originalHTML = normalizedContent;
                document.getElementById('sourceContent').innerHTML = originalHTML;
                
                // Step 4: Preserve visual fidelity from the actually rendered content (with all CSS applied)
                // Wait longer for CSS to fully load and apply - this is critical for accurate inheritance
                await new Promise(resolve => requestAnimationFrame(resolve));
                await new Promise(resolve => setTimeout(resolve, 100)); // Additional delay for CSS resolution
                
                // Force reflow to ensure all styles are computed
                const sourceContainer = document.getElementById('sourceContent');
                sourceContainer.offsetHeight; // Force layout recalculation
                
                preserveVisualFidelity(sourceContainer);
                
                // Show processed content first to ensure elements are visible for measurement
                const sourceContent = document.getElementById('sourceContent');
                const paginatedContent = document.getElementById('paginatedContent');
                
                sourceContent.style.display = 'block';
                sourceContent.style.height = 'auto';
                sourceContent.style.minHeight = '100vh';
                sourceContent.style.maxHeight = 'none';
                sourceContent.style.overflow = 'visible';
                sourceContent.style.visibility = 'visible';
                sourceContent.style.position = 'static';
                paginatedContent.style.display = 'none';
                
                // Ensure all children are visible and have proper layout BEFORE measurement
                const allElements = sourceContent.querySelectorAll('*');
                allElements.forEach(elem => {
                    if (elem.style.display === 'none') elem.style.display = '';
                    if (elem.style.visibility === 'hidden') elem.style.visibility = 'visible';
                    if (elem.style.height === '0px') elem.style.height = 'auto';
                });
                
                // Force reflow before measurement
                sourceContent.offsetHeight;
                
                // Step 4: Prepare for measurement (but don't paginate yet) - NOW elements are visible
                await measureElements(normalizedContent);
                
                // Update workflow: Step 1 completed, enable Step 2
                updateWorkflowStep(1, 'completed');
                updateWorkflowStep(2, 'active');
                document.getElementById('paginateBtn').disabled = false;
                
                // Force multiple reflows to ensure proper rendering
                setTimeout(() => {
                    sourceContent.style.minHeight = 'auto';
                    sourceContent.offsetHeight; // Trigger reflow
                    setTimeout(() => {
                        // Final height adjustment
                        const computedHeight = sourceContent.scrollHeight;
                        sourceContent.style.minHeight = Math.max(computedHeight, window.innerHeight) + 'px';
                    }, 100);
                }, 50);
                
                updateStatus('HTML processed and cleaned! Ready for pagination.', 'success');
                
            } catch (error) {
                console.error('Error processing HTML:', error);
                updateStatus('Error processing HTML: ' + error.message, 'error');
            }
        }

        // Smart HTML structure analysis - understand containers vs content
        function analyzeHTMLStructure(element) {
            const contentElements = [];
            
            // Define what we consider "content containers" vs "layout containers"
            const contentTags = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'TABLE', 'UL', 'OL', 'BLOCKQUOTE', 'PRE', 'IMG', 'FIGURE'];
            const layoutContainers = ['DIV', 'SECTION', 'ARTICLE', 'MAIN', 'HEADER', 'FOOTER', 'ASIDE'];
            
            // Special classes that should NEVER be split across pages
            const indivisibleClasses = ['callout', 'warning', 'success', 'info', 'alert', 'card', 'box'];
            
            function traverseElement(el) {
                const tagName = el.tagName;
                const hasIndivisibleClass = indivisibleClasses.some(cls => el.classList.contains(cls));
                
                // Check if this element should be treated as indivisible
                if (hasIndivisibleClass) {
                    // Callout boxes and similar styled containers must not be split
                    contentElements.push({
                        element: el,
                        height: el.offsetHeight,
                        type: 'indivisible-content'
                    });
                    return; // Don't traverse children - treat as single unit
                }
                
                if (contentTags.includes(tagName)) {
                    // This is actual content - add it for measurement
                    if (tagName === 'TABLE') {
                        // Smart table handling - check if table should be treated as unit or split
                        const tableHeight = el.offsetHeight;
                        const maxTableHeight = 800; // Tables larger than this should be split
                        
                        if (tableHeight <= maxTableHeight) {
                            // Small/medium table - treat as indivisible unit
                            contentElements.push({
                                element: el,
                                height: tableHeight,
                                type: 'indivisible-content' // This prevents splitting
                            });
                        } else {
                            // Large table - extract rows for flexible pagination
                            const tbody = el.querySelector('tbody');
                            if (tbody) {
                                const rows = Array.from(tbody.querySelectorAll('tr'));
                                rows.forEach(row => {
                                    contentElements.push({
                                        element: row,
                                        height: row.offsetHeight,
                                        type: 'table-row',
                                        parentTable: el
                                    });
                                });
                            }
                        }
                    } else {
                        // Regular content element
                        contentElements.push({
                            element: el,
                            height: el.offsetHeight,
                            type: 'content'
                        });
                    }
                } else if (layoutContainers.includes(tagName)) {
                    // Check if this is a small styled container that should be treated as content
                    const computedStyle = window.getComputedStyle(el);
                    const hasVisualStyling = 
                        computedStyle.backgroundColor !== 'rgba(0, 0, 0, 0)' ||
                        computedStyle.borderRadius !== '0px' ||
                        computedStyle.backgroundImage !== 'none' ||
                        computedStyle.boxShadow !== 'none' ||
                        computedStyle.border !== '0px none rgb(51, 51, 51)' ||
                        el.style.background !== '';
                    
                    // Check if element has margins that suggest it's a spaced card
                    const marginBottom = parseFloat(computedStyle.marginBottom) || 0;
                    const marginTop = parseFloat(computedStyle.marginTop) || 0;
                    const hasSignificantMargins = marginBottom > 10 || marginTop > 10;
                    
                    // Only treat as content unit if it's small enough AND has visual styling OR significant margins
                    const elementHeight = el.offsetHeight;
                    const maxContentHeight = 400; // More conservative - only truly small elements should be indivisible
                    
                    // Be more selective about what we consider "indivisible"
                    const isSmallStyledElement = (hasVisualStyling || hasSignificantMargins) && elementHeight <= maxContentHeight;
                    const isCalloutOrCard = el.classList.contains('callout') || el.classList.contains('card') || el.classList.contains('note');
                    
                    if (isSmallStyledElement || (isCalloutOrCard && elementHeight <= 800)) {
                        // Small styled element or specific card types - treat as indivisible
                        contentElements.push({
                            element: el,
                            height: elementHeight,
                            type: 'indivisible-content'
                        });
                    } else {
                        // Large container or unstyled - traverse its children
                        Array.from(el.children).forEach(child => {
                            traverseElement(child);
                        });
                    }
                } else {
                    // Unknown element - treat as content if it has text/no children, container otherwise
                    if (el.children.length === 0 && el.textContent.trim()) {
                        // Text content
                        contentElements.push({
                            element: el,
                            height: el.offsetHeight,
                            type: 'content'
                        });
                    } else if (el.children.length > 0) {
                        // Has children - traverse
                        Array.from(el.children).forEach(child => {
                            traverseElement(child);
                        });
                    }
                }
            }
            
            traverseElement(element);
            return contentElements;
        }
        
        // Handle different content types with smart analysis
        function processContentByType(element) {
            return analyzeHTMLStructure(element);
        }

        // AGGRESSIVE measurement function for maximum space utilization
        function getAccurateElementHeight(element) {
            // Instead of cloning to a hidden container, measure the element directly in place
            // This ensures all CSS styles are properly applied
            const elementStyle = window.getComputedStyle(element);
            
            // If element is currently visible, use its actual dimensions
            if (element.offsetHeight > 0) {
                const marginTop = parseFloat(elementStyle.marginTop) || 0;
                const marginBottom = parseFloat(elementStyle.marginBottom) || 0;
                const actualHeight = element.offsetHeight + marginTop + marginBottom;
                
                // AGGRESSIVE: Reduce buffer sizes for tighter packing
                const buffer = (element.tagName === 'TABLE' || 
                               element.classList.contains('two-column') ||
                               element.classList.contains('text-box') ||
                               element.classList.contains('stat-box')) ? 4 : 2; // Reduced buffers
                
                // Element measurement: ${element.tagName}.${element.className || 'no-class'} - ${actualHeight + buffer}px
                return Math.ceil(actualHeight) + buffer;
            }
            
            // For elements with 0 height, create a better measurement container
            const tempContainer = document.createElement('div');
            tempContainer.style.cssText = `
                position: absolute;
                top: -9999px;
                left: -9999px;
                visibility: hidden;
                width: 800px;
                max-width: 100%;
                padding: 0.6cm;
                font-family: Helvetica, Arial, sans-serif;
                line-height: 1.4;
                font-size: 11pt;
                box-sizing: border-box;
                background: white;
            `;
            
            // Copy all stylesheets to ensure proper styling
            const allStyles = document.querySelectorAll('style, link[rel="stylesheet"]');
            allStyles.forEach(style => {
                if (style.tagName === 'STYLE') {
                    const newStyle = document.createElement('style');
                    newStyle.textContent = style.textContent;
                    tempContainer.appendChild(newStyle);
                }
            });
            
            // Clone the element and ensure it's visible
            const clonedElement = element.cloneNode(true);
            clonedElement.style.display = '';
            clonedElement.style.visibility = 'visible';
            clonedElement.style.height = 'auto';
            tempContainer.appendChild(clonedElement);
            document.body.appendChild(tempContainer);
            
            // Force layout calculation
            tempContainer.offsetHeight;
            
            // Get the accurate height including margins and borders
            const computedStyle = window.getComputedStyle(clonedElement);
            const marginTop = parseFloat(computedStyle.marginTop) || 0;
            const marginBottom = parseFloat(computedStyle.marginBottom) || 0;
            const paddingTop = parseFloat(computedStyle.paddingTop) || 0;
            const paddingBottom = parseFloat(computedStyle.paddingBottom) || 0;
            
            // Include full spacing in height calculation to preserve gaps between cards
            const actualHeight = clonedElement.offsetHeight + marginTop + marginBottom;
            
            // Clean up
            document.body.removeChild(tempContainer);
            
            // Reduced safety buffer for better space utilization
            const buffer = (clonedElement.tagName === 'TABLE' || 
                           clonedElement.classList.contains('two-column') ||
                           clonedElement.classList.contains('text-box') ||
                           clonedElement.classList.contains('stat-box')) ? 8 : 4; // Reduced buffer for better space usage
            
            // Element measured: ${element.tagName}.${element.className || 'no-class'} - ${actualHeight + buffer}px
            
            return Math.ceil(actualHeight) + buffer;
        }

        // Measure all elements in the content and add spacing between cards
        async function measureElements(content) {
            console.log('Starting enhanced element measurement...');
            
            const measurementContainer = document.getElementById('measurementContainer');
            measurementContainer.innerHTML = content;
            
            // Apply exact page styling to measurement container
            measurementContainer.style.cssText = `
                position: absolute;
                top: -9999px;
                left: -9999px;
                visibility: hidden;
                width: 210mm;
                padding: 0.6cm;
                font-family: Helvetica, Arial, sans-serif;
                line-height: 1.4;
                font-size: 11pt;
                box-sizing: border-box;
            `;
            
            // Force layout calculation
            measurementContainer.offsetHeight;
            
            // Get all top-level elements that should be measured individually
            // Handle both wrapped and unwrapped content
            let elements;
            if (measurementContainer.children.length === 1 && measurementContainer.children[0].children.length > 0) {
                // Content is wrapped in a container
                elements = Array.from(measurementContainer.children[0].children);
            } else {
                // Content is not wrapped or multiple top-level elements
                elements = Array.from(measurementContainer.children);
            }
            
            processedElements = [];
            elementHeights = [];
            
            console.log(`Total elements found: ${elements.length}`);
            // Elements detected for processing
            
            elements.forEach((element, index) => {
                const processedItems = processContentByType(element);
                
                processedItems.forEach((item, itemIndex) => {
                    // Use enhanced height measurement for better accuracy
                    const accurateHeight = getAccurateElementHeight(item.element);
                    item.height = accurateHeight;
                    
                    processedElements.push(item);
                    elementHeights.push(accurateHeight);
                    
                    // Enhanced measurement - Element ${index + 1}.${itemIndex + 1}: ${item.element.tagName}.${item.element.className || 'no-class'} - ${accurateHeight}px
                });
                
                // AGGRESSIVE SPACING: Minimal spacing for maximum content density
                if (index < elements.length - 1) {
                    const currentStyle = window.getComputedStyle(element);
                    const nextElement = elements[index + 1];
                    const nextStyle = window.getComputedStyle(nextElement);
                    
                    const marginBottom = parseFloat(currentStyle.marginBottom) || 0;
                    const marginTop = parseFloat(nextStyle.marginTop) || 0;
                    
                    // AGGRESSIVE: Reduce spacing for maximum content density
                    const spacing = Math.max(marginBottom, marginTop) * 0.6; // 40% reduction in spacing
                    
                    if (spacing > 3) { // Lower threshold for meaningful gaps - tighter packing
                        const spacer = document.createElement('div');
                        spacer.style.height = spacing + 'px';
                        spacer.style.width = '100%';
                        spacer.style.backgroundColor = 'transparent';
                        spacer.className = 'spacing-element';
                        
                        const spacingItem = {
                            element: spacer,
                            height: spacing,
                            type: 'spacing'
                        };
                        
                        processedElements.push(spacingItem);
                        elementHeights.push(spacing);
                        
                        // Added reduced spacing element: ${spacing}px between elements
                    }
                }
            });
            
            console.log(`Total elements measured (including spacing): ${processedElements.length}`);
            console.log('Height distribution:', elementHeights.sort((a, b) => b - a).slice(0, 10), '(top 10 largest)');
        }

        // Create a new page
        function createNewPage(pageNumber, needsTable = false, tableTemplate = null) {
            const page = document.createElement('div');
            page.className = 'page';
            
            const content = document.createElement('div');
            content.className = 'page-content';
            
            // PRESERVE CSS CONTEXT: Ensure paginated pages have same CSS environment as processed content
            // Copy the body class and any data attributes that might affect CSS inheritance
            const processedContent = document.getElementById('processedContent');
            if (processedContent) {
                const bodyElement = processedContent.closest('body') || document.body;
                if (bodyElement.className) {
                    page.classList.add(...bodyElement.className.split(' '));
                }
                
                // Copy any data attributes that affect styling
                Array.from(bodyElement.attributes).forEach(attr => {
                    if (attr.name.startsWith('data-') && !page.hasAttribute(attr.name)) {
                        page.setAttribute(attr.name, attr.value);
                    }
                });
            }
            
            // Add data attribute to help with CSS targeting
            content.setAttribute('data-preserve-spacing', 'true');
            
            if (needsTable && tableTemplate) {
                // Create table with header for table rows - preserve all styling
                const table = tableTemplate.cloneNode(true);
                const tbody = table.querySelector('tbody');
                if (tbody) tbody.innerHTML = ''; // Clear body, keep header
                
                // Preserve the table container structure from original
                const tableContainer = document.createElement('div');
                tableContainer.className = 'table-container';
                tableContainer.appendChild(table);
                content.appendChild(tableContainer);
            }
            
            page.appendChild(content);
            document.getElementById('paginatedContent').appendChild(page);
            
            // Initialize page height tracking
            pageHeights.set(page, 0);
            
            return { page, content, table: needsTable ? content.querySelector('table') : null };
        }

        // Track cumulative height per page
        const pageHeights = new Map(); // page -> cumulative height
        
        // Enhanced function to preserve computed styles when cloning elements
        function cloneElementWithStyles(originalElement) {
            const clone = originalElement.cloneNode(true);
            const originalStyles = window.getComputedStyle(originalElement);
            
            // Visual properties that must be preserved to maintain fidelity
            const criticalVisualProps = [
                'font-family', 'font-size', 'font-weight', 'font-style', 'line-height', 
                'color', 'background-color', 'background-image', 'background', 
                'border', 'border-radius', 'border-color', 'border-style', 'border-width',
                'padding', 'margin', 'text-align', 'text-decoration', 'text-transform',
                'box-shadow', 'opacity', 'gap'
            ];
            
            // Properties to exclude from cloning to prevent layout issues
            const excludeFromCloning = [
                'position', 'top', 'right', 'bottom', 'left', 'z-index',
                'width', 'height', 'min-width', 'min-height', 'max-width', 'max-height',
                'overflow', 'overflow-x', 'overflow-y', 'display'
            ];
            
            // Apply all critical visual properties as inline styles to ensure they're preserved
            criticalVisualProps.forEach(prop => {
                if (!excludeFromCloning.includes(prop)) {
                    const value = originalStyles.getPropertyValue(prop);
                    if (value && value !== 'none' && value !== 'auto' && value !== 'normal' && value !== 'initial') {
                        clone.style.setProperty(prop, value, 'important');
                    }
                }
            });
            
            // Let normal visual properties inheritance handle all table styling including border-radius
            
            // Recursively apply styles to all child elements
            const originalChildren = originalElement.querySelectorAll('*');
            const clonedChildren = clone.querySelectorAll('*');
            
            originalChildren.forEach((child, index) => {
                if (clonedChildren[index]) {
                    const childStyles = window.getComputedStyle(child);
                    criticalVisualProps.forEach(prop => {
                        if (!excludeFromCloning.includes(prop)) {
                            const value = childStyles.getPropertyValue(prop);
                            if (value && value !== 'none' && value !== 'auto' && value !== 'normal' && value !== 'initial') {
                                clonedChildren[index].style.setProperty(prop, value, 'important');
                            }
                        }
                    });
                }
            });
            
            return clone;
        }
        
        // Legacy function - keeping for compatibility
        function cloneElementWithStylesLegacy(originalElement) {
            const clone = originalElement.cloneNode(true);
            const originalStyles = window.getComputedStyle(originalElement);
            
            // Preserve ALL spacing and visual properties to maintain exact appearance
            const importantProps = [
                'margin-top', 'margin-bottom', 'margin-left', 'margin-right',
                'padding-top', 'padding-bottom', 'padding-left', 'padding-right',
                'border-top', 'border-bottom', 'border-left', 'border-right',
                'background-color', 'background-image', 'background-size', 'background-position',
                'border-radius', 'box-shadow', 'display'
            ];
            
            importantProps.forEach(prop => {
                const value = originalStyles.getPropertyValue(prop);
                if (value && value !== 'initial' && value !== 'normal') {
                    clone.style.setProperty(prop, value, 'important');
                }
            });
            
            // Preserve class names which may contain styling
            clone.className = originalElement.className;
            
            // Copy any inline styles
            if (originalElement.style.cssText) {
                clone.style.cssText += '; ' + originalElement.style.cssText;
            }
            
            return clone;
        }
        
        // Measure remaining space in page - use cumulative approach  
        function getRemainingSpace(page) {
            // Enhanced space utilization - more aggressive page filling
            // A4 is 297mm height. At 96 DPI: 297mm = 1123px approximately
            const pageHeightPx = 1123;
            // Reduce padding for better space utilization (was 23*2 = 46px, now 18*2 = 36px)
            const paddingPx = 18 * 2; // More aggressive padding for better space usage
            const availableHeight = pageHeightPx - paddingPx;
            
            // Get cumulative height for this page
            const currentHeight = pageHeights.get(page) || 0;
            const remainingSpace = availableHeight - currentHeight;
            
            console.log(`Page height: ${pageHeightPx}px, Available: ${availableHeight}px, Current: ${currentHeight}px, Remaining: ${remainingSpace}px`);
            
            return remainingSpace;
        }
        
        // Add element height to page tracking
        function addElementHeightToPage(page, elementHeight) {
            const currentHeight = pageHeights.get(page) || 0;
            pageHeights.set(page, currentHeight + elementHeight);
        }

        // Real-time cumulative height measurement during pagination
        function measureCumulativeHeight(pageContent) {
            // Create temporary page container with exact styling
            const tempPage = document.createElement('div');
            tempPage.className = 'page';
            tempPage.style.cssText = `
                position: absolute;
                top: -9999px;
                left: -9999px;
                visibility: hidden;
                width: 210mm;
                min-height: auto;
                background: white;
                padding: 0.6cm;
                box-sizing: border-box;
                font-family: Helvetica, Arial, sans-serif;
                line-height: 1.4;
                font-size: 11pt;
            `;
            
            // Clone all current page content
            const tempContent = document.createElement('div');
            tempContent.className = 'page-content';
            Array.from(pageContent.children).forEach(child => {
                tempContent.appendChild(child.cloneNode(true));
            });
            
            tempPage.appendChild(tempContent);
            document.body.appendChild(tempPage);
            
            // Force layout and measure - be more thorough
            tempPage.offsetHeight; // Force layout
            tempContent.offsetHeight; // Force content layout
            
            // Use the larger of scrollHeight and offsetHeight to ensure we capture all content
            const scrollHeight = tempContent.scrollHeight;
            const offsetHeight = tempContent.offsetHeight;
            const actualHeight = Math.max(scrollHeight, offsetHeight);
            
            console.log(`Height measurement: scrollHeight=${scrollHeight}, offsetHeight=${offsetHeight}, using=${actualHeight}`);
            
            // Cleanup
            document.body.removeChild(tempPage);
            
            return actualHeight;
        }

        // RADICAL NEW APPROACH: CSS-Based Natural Flow Pagination
        // Let browser handle pagination naturally with CSS page-break controls
        async function paginateContent() {
            const sourceContent = document.getElementById('sourceContent');
            if (!sourceContent || !sourceContent.innerHTML.trim()) {
                updateStatus('Please process HTML first before paginating', 'error');
                return;
            }
            
            console.log('=== STARTING CSS-BASED NATURAL FLOW PAGINATION ===');
            updateStatus('Creating natural flow pagination with CSS page breaks...');
            
            // Clear existing paginated content
            const paginatedContent = document.getElementById('paginatedContent');
            paginatedContent.innerHTML = '';
            
            // Add preserved styles to ensure proper styling
            if (preservedStyles) {
                paginatedContent.insertAdjacentHTML('afterbegin', preservedStyles);
            }
            
            // Create single flowing container with CSS pagination controls
            const flowContainer = document.createElement('div');
            flowContainer.className = 'natural-flow-container';
            flowContainer.innerHTML = sourceContent.innerHTML;
            
            // Apply CSS pagination rules for natural page breaking
            addPaginationCSS();
            
            // Add the container to paginated content
            paginatedContent.appendChild(flowContainer);
            
            // Create actual visual pages from the natural flow content
            createVisualPagesFromFlow(flowContainer);
            
            // Update workflow and UI
            updateWorkflowStep(2, 'completed');
            updateStatus('✅ Natural flow pagination completed with perfect visual fidelity!', 'success');
            document.getElementById('paginatedContent').style.display = 'block';
            document.getElementById('sourceContent').style.display = 'none';
            
            console.log('=== CSS PAGINATION COMPLETED ===');
        }
        
        // Add CSS rules for natural pagination
        function addPaginationCSS() {
            const style = document.createElement('style');
            style.textContent = `
                /* Natural flow pagination CSS */
                .natural-flow-container {
                    width: 210mm;
                    max-width: 100%;
                    margin: 0 auto;
                    background: white;
                    padding: 0.6cm;
                    box-sizing: border-box;
                    font-family: Helvetica, Arial, sans-serif;
                    font-size: 11pt;
                    line-height: 1.4;
                    
                    /* Page break controls */
                    page-break-inside: auto;
                }
                
                /* Visual page separators every A4 height */
                .natural-flow-container::after {
                    content: '';
                    display: block;
                    height: 1px;
                    background: transparent;
                    margin: 297mm 0 20px 0;
                }
                
                /* Table pagination rules */
                .natural-flow-container table {
                    page-break-inside: auto;
                    break-inside: auto;
                }
                
                .natural-flow-container thead {
                    display: table-header-group;
                    page-break-after: auto;
                    break-after: auto;
                }
                
                .natural-flow-container tbody {
                    display: table-row-group;
                    page-break-inside: auto;
                    break-inside: auto;
                }
                
                .natural-flow-container tr {
                    page-break-inside: avoid;
                    break-inside: avoid;
                    page-break-after: auto;
                    break-after: auto;
                }
                
                /* Prevent orphans and widows */
                .natural-flow-container p,
                .natural-flow-container div,
                .natural-flow-container h1, .natural-flow-container h2, .natural-flow-container h3 {
                    orphans: 2;
                    widows: 2;
                }
                
                /* ENHANCED: Improved visual page boundaries for screen view */
                .page-boundary {
                    height: 2px;
                    background: linear-gradient(90deg, #e0e0e0 0%, #f0f0f0 50%, #e0e0e0 100%);
                    margin: 25px 0;
                    position: relative;
                    border-radius: 1px;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                }
                
                .page-boundary::after {
                    content: 'Page Break';
                    position: absolute;
                    right: 0;
                    top: -10px;
                    font-size: 10px;
                    color: #999;
                }
                
                /* FIXED: A4 Page styling with proper overflow control */
                .page {
                    width: 210mm;
                    min-height: 297mm;
                    max-height: 297mm; /* CRITICAL: Restore height constraint to prevent overflow */
                    padding: 0.6cm;
                    margin: 0 auto 20px auto;
                    background: white;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    page-break-after: always;
                    position: relative;
                    overflow: hidden; /* CRITICAL: Prevent text overflow beyond page */
                    box-sizing: border-box;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                }
                
                .page-content {
                    width: 100%;
                    height: 100%;
                    overflow: hidden;
                    position: relative;
                }
                
                /* Page number styling */
                .page::after {
                    content: "Page " counter(page);
                    position: absolute;
                    bottom: 10mm;
                    right: 20mm;
                    font-size: 10px;
                    color: #666;
                    font-family: Arial, sans-serif;
                }
                
                /* Counter for page numbers */
                #paginatedContent {
                    counter-reset: page;
                }
                
                #paginatedContent .page {
                    counter-increment: page;
                }
            `;
            document.head.appendChild(style);
        }
        
        // INTELLIGENT PAGE BREAKING with Lookahead Optimization
        function createVisualPagesFromFlow(flowContainer) {
            console.log('=== INTELLIGENT PAGINATION WITH LOOKAHEAD OPTIMIZATION ===');
            
            // DON'T remove flowContainer yet - we need it in DOM for accurate measurement
            const paginatedContent = document.getElementById('paginatedContent');
            
            // Force layout calculation to ensure accurate measurements
            flowContainer.style.display = 'block';
            flowContainer.style.visibility = 'visible';
            flowContainer.offsetHeight; // Force reflow
            
            // BALANCED A4 dimensions - prevent overflow while maximizing content
            const A4_HEIGHT_PX = 950; // Reduced from 1000 to prevent text overflow
            const MIN_FILL_THRESHOLD = 0.85; // Balanced 85% utilization to ensure content fits
            
            // Get all content elements with accurate measurement
            const allContentElements = extractContentElements(flowContainer);
            console.log(`📊 Processing ${allContentElements.length} content elements...`);
            
            // ENHANCED: Accurate measurement with DOM rendering
            const elementData = measureElementsAccurately(allContentElements);
            
            // Clear and prepare paginated content
            paginatedContent.innerHTML = '';
            if (preservedStyles) {
                paginatedContent.insertAdjacentHTML('afterbegin', preservedStyles);
            }
            
            // INTELLIGENT PAGINATION with lookahead optimization
            const pages = createOptimalPages(elementData, A4_HEIGHT_PX, MIN_FILL_THRESHOLD);
            
            // Render optimized pages
            pages.forEach((pageData, index) => {
                const page = createStyledPage(index + 1);
                pageData.elements.forEach(element => {
                    page.content.appendChild(element.cloneNode(true));
                });
                
                const utilizationPercent = ((pageData.totalHeight / A4_HEIGHT_PX) * 100).toFixed(1);
                console.log(`📄 Page ${index + 1}: ${utilizationPercent}% utilized (${pageData.totalHeight}/${A4_HEIGHT_PX}px, ${pageData.elements.length} elements)`);
            });
            
            // Performance analytics
            const totalHeight = pages.reduce((sum, page) => sum + page.totalHeight, 0);
            const averageUtilization = ((totalHeight / (pages.length * A4_HEIGHT_PX)) * 100).toFixed(1);
            const wastedSpace = (pages.length * A4_HEIGHT_PX) - totalHeight;
            
            console.log(`🎯 OPTIMIZATION RESULTS:`);
            console.log(`   📚 Total Pages: ${pages.length}`);
            console.log(`   📊 Average Utilization: ${averageUtilization}%`);
            console.log(`   💾 Space Saved: ${wastedSpace}px (${(wastedSpace/A4_HEIGHT_PX).toFixed(1)} pages worth)`);
            console.log(`🎉 INTELLIGENT PAGINATION COMPLETE!`);
        }
        
        // Create a properly styled A4 page
        function createStyledPage(pageNumber) {
            const page = document.createElement('div');
            page.className = 'page';
            
            const content = document.createElement('div');
            content.className = 'page-content';
            
            page.appendChild(content);
            document.getElementById('paginatedContent').appendChild(page);
            
            return { page, content };
        }
        
        // ENHANCED: Extract content elements from flow container
        function extractContentElements(flowContainer) {
            const allContentElements = [];
            Array.from(flowContainer.children).forEach(wrapper => {
                if (wrapper.classList.contains('extracted-page-content')) {
                    // Add children of wrapper (the actual content)
                    Array.from(wrapper.children).forEach(child => {
                        if (child.tagName !== 'STYLE') {
                            allContentElements.push(child);
                        }
                    });
                } else if (wrapper.tagName !== 'STYLE') {
                    // Add non-wrapper elements directly
                    allContentElements.push(wrapper);
                }
            });
            return allContentElements;
        }
        
        // ACCURATE: Measure elements using actual DOM rendering
        function measureElementsAccurately(elements) {
            console.log('🔍 Performing accurate DOM-based measurements...');
            
            return elements.map((element, index) => {
                const height = getAccurateElementHeight(element);
                const priority = getElementPriority(element);
                const canSplit = isElementSplittable(element);
                
                console.log(`📏 Element ${index + 1}: ${element.tagName}.${element.className || 'no-class'} - ${height}px (priority: ${priority}, splittable: ${canSplit})`);
                
                return {
                    element: element,
                    height: height,
                    priority: priority,
                    canSplit: canSplit,
                    index: index
                };
            });
        }
        
        // Determine element priority for optimal placement
        function getElementPriority(element) {
            const tag = element.tagName.toLowerCase();
            const className = element.className || '';
            
            // High priority (prefer to keep together)
            if (tag === 'table' || className.includes('callout') || className.includes('stat-box')) {
                return 'high';
            }
            // Medium priority (headings should stay with following content)
            if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)) {
                return 'medium';
            }
            // Low priority (can be flexibly placed)
            return 'low';
        }
        
        // Check if element can be split across pages
        function isElementSplittable(element) {
            const tag = element.tagName.toLowerCase();
            const className = element.className || '';
            
            // Never split these elements
            if (tag === 'table' || tag === 'img' || tag === 'figure' || 
                className.includes('callout') || className.includes('stat-box') ||
                className.includes('text-box')) {
                return false;
            }
            
            // Large text blocks can be split if necessary
            if (['div', 'section', 'article'].includes(tag) && element.textContent.length > 500) {
                return true;
            }
            
            return false;
        }
        
        // INTELLIGENT: Create optimal pages with lookahead algorithm
        function createOptimalPages(elementData, pageHeight, minFillThreshold) {
            console.log('🧠 Running intelligent page optimization algorithm...');
            
            const pages = [];
            let currentPageElements = [];
            let currentPageHeight = 0;
            let elementIndex = 0;
            
            while (elementIndex < elementData.length) {
                const element = elementData[elementIndex];
                
                // Check if element fits on current page
                if (currentPageHeight + element.height <= pageHeight) {
                    // Element fits - add it
                    currentPageElements.push(element.element);
                    currentPageHeight += element.height;
                    elementIndex++;
                } else {
                    // Element doesn't fit - apply intelligent decision making
                    const decision = makeIntelligentPageDecision(
                        elementData, elementIndex, currentPageHeight, 
                        pageHeight, minFillThreshold
                    );
                    
                    if (decision.action === 'finish_page') {
                        // Finish current page and start new one
                        if (currentPageElements.length > 0) {
                            pages.push({
                                elements: currentPageElements,
                                totalHeight: currentPageHeight
                            });
                        }
                        currentPageElements = [];
                        currentPageHeight = 0;
                    } else if (decision.action === 'force_fit') {
                        // Force fit the element (for small overflows)
                        currentPageElements.push(element.element);
                        currentPageHeight += element.height;
                        elementIndex++;
                    } else if (decision.action === 'skip_and_pack') {
                        // Skip current element and try to pack smaller ones
                        const packedElements = packSmallerElements(
                            elementData, elementIndex + 1, pageHeight - currentPageHeight
                        );
                        
                        packedElements.forEach(el => {
                            currentPageElements.push(el.element);
                            currentPageHeight += el.height;
                        });
                        
                        // Remove packed elements from remaining list
                        packedElements.forEach(el => {
                            const idx = elementData.findIndex(item => item.index === el.index);
                            if (idx > elementIndex) {
                                elementData.splice(idx, 1);
                            }
                        });
                        
                        // Finish page and add skipped element to next page
                        pages.push({
                            elements: currentPageElements,
                            totalHeight: currentPageHeight
                        });
                        currentPageElements = [element.element];
                        currentPageHeight = element.height;
                        elementIndex++;
                    }
                }
            }
            
            // Add final page if it has content
            if (currentPageElements.length > 0) {
                pages.push({
                    elements: currentPageElements,
                    totalHeight: currentPageHeight
                });
            }
            
            return pages;
        }
        
        // Make intelligent decisions about page breaks
        function makeIntelligentPageDecision(elementData, currentIndex, currentHeight, pageHeight, minThreshold) {
            const element = elementData[currentIndex];
            const overflow = (currentHeight + element.height) - pageHeight;
            const currentUtilization = currentHeight / pageHeight;
            
            // If current page is well-utilized (>= threshold), finish it
            if (currentUtilization >= minThreshold) {
                return { action: 'finish_page' };
            }
            
            // Small overflow with high-priority element - force fit
            if (overflow <= 50 && element.priority === 'high') {
                return { action: 'force_fit' };
            }
            
            // Large element that would waste space - skip and pack smaller ones
            if (element.height > pageHeight * 0.6 && currentUtilization < 0.7) {
                return { action: 'skip_and_pack' };
            }
            
            // Default: finish current page
            return { action: 'finish_page' };
        }
        
        // Pack smaller elements to fill remaining space
        function packSmallerElements(elementData, startIndex, remainingSpace) {
            const packed = [];
            let usedSpace = 0;
            
            for (let i = startIndex; i < elementData.length && usedSpace < remainingSpace; i++) {
                const element = elementData[i];
                if (usedSpace + element.height <= remainingSpace + 20) { // 20px tolerance
                    packed.push(element);
                    usedSpace += element.height;
                }
            }
            
            return packed;
        }

        // Download PDF using jsPDF - direct PDF generation
        async function downloadPDF() {
            console.log('downloadPDF function called');
            
            // Prevent concurrent PDF generation
            if (isPDFGenerating) {
                console.log('PDF generation already in progress, ignoring request');
                return;
            }
            
            const paginatedContent = document.getElementById('paginatedContent');
            if (!paginatedContent.children.length) {
                alert('Please paginate the content first before downloading PDF.');
                return;
            }
            
            // jsPDF direct HTML rendering doesn't need html2canvas for better fidelity
            
            if (!window.jspdf) {
                updateStatus('Error: jsPDF library not loaded. Please check your internet connection.', 'error');
                alert('PDF generation requires internet connection to load jsPDF library.\n\nPlease:\n1. Check your internet connection\n2. Refresh the page\n3. Try again');
                return;
            }
            
            // Set flag and disable download button
            isPDFGenerating = true;
            const downloadButton = document.querySelector('[onclick="downloadPDF()"]');
            if (downloadButton) {
                downloadButton.disabled = true;
                downloadButton.textContent = 'Generating PDF...';
            }
            
            updateStatus('Generating high-quality PDF using native HTML rendering... This may take a moment.');
            
            try {
                const { jsPDF } = window.jspdf;
                
                // ENHANCED: Use jsPDF's native HTML rendering for perfect visual fidelity
                const pages = Array.from(paginatedContent.querySelectorAll('.page'));
                
                // Ensure all pages are visible for HTML rendering
                const originalPageStyles = [];
                pages.forEach((page, idx) => {
                    originalPageStyles[idx] = {
                        display: page.style.display,
                        visibility: page.style.visibility,
                        position: page.style.position,
                        opacity: page.style.opacity
                    };
                    
                    page.style.display = 'block';
                    page.style.visibility = 'visible';
                    page.style.position = 'relative';
                    page.style.opacity = '1';
                });
                
                // Force layout recalculation
                paginatedContent.offsetHeight;
                
                // BRILLIANT INSIGHT: Use the perfect paginated HTML directly!
                updateStatus('Converting paginated HTML directly to PDF...');
                
                // Get the entire paginated content as it exists - perfectly formatted
                const paginatedHTML = paginatedContent.innerHTML;
                
                console.log(`Converting ${pages.length} perfectly paginated pages to PDF...`);
                
                // Create a complete HTML document with the paginated content
                const fullHTML = `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <style>
                        @page { size: A4; margin: 0.6cm; }
                        body { font-family: Arial, sans-serif; font-size: 11pt; line-height: 1.4; margin: 0; padding: 0; }
                        .page { width: 100%; min-height: 277mm; page-break-after: always; background: white; }
                        .page:last-child { page-break-after: auto; }
                        .page-content { width: 100%; height: 100%; }
                        table { border-collapse: collapse; width: 100%; margin: 10px 0; }
                        th, td { border: 1px solid black; padding: 8px; text-align: left; }
                        th { background-color: #f5f5f5; font-weight: bold; }
                        h1 { font-size: 18pt; font-weight: bold; margin: 20px 0 10px 0; }
                        h2 { font-size: 14pt; font-weight: bold; margin: 15px 0 8px 0; }
                        h3 { font-size: 12pt; font-weight: bold; margin: 12px 0 6px 0; }
                        p { margin: 8px 0; }
                        ul, ol { margin: 10px 0 10px 20px; }
                        li { margin: 2px 0; }
                        .callout { background: #f8f9fa; border-left: 4px solid #007bff; padding: 10px 15px; margin: 10px 0; }
                        .callout.warning { border-left-color: #ffc107; }
                        .callout.note { border-left-color: #007bff; }
                        img, svg, canvas { display: none !important; }
                        .controls, .file-input, .status, .measurement-container { display: none !important; }
                    </style>
                </head>
                <body>
                    ${paginatedHTML}
                </body>
                </html>`;
                
                // Create PDF using jsPDF's html method with the complete document
                const pdf = new jsPDF('p', 'mm', 'a4');
                
                // Create a temporary element with the full HTML
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = paginatedHTML;
                tempDiv.style.cssText = `
                    position: absolute;
                    top: -9999px;
                    left: -9999px;
                    width: 794px;
                    background: white;
                    font-family: Arial, sans-serif;
                    font-size: 11pt;
                    line-height: 1.4;
                `;
                
                document.body.appendChild(tempDiv);
                
                // Convert using jsPDF html method
                await pdf.html(tempDiv, {
                    callback: function(doc) {
                        // Clean up
                        if (document.body.contains(tempDiv)) {
                            document.body.removeChild(tempDiv);
                        }
                        
                        // Save the PDF
                        const baseFileName = originalFileName || 'document';
                        const filename = `${baseFileName}_paginated.pdf`;
                        const pdfBlob = doc.output('blob');
                        const fileSizeMB = (pdfBlob.size / (1024 * 1024)).toFixed(2);
                        
                        doc.save(filename);
                        updateStatus(`✅ PDF generated from paginated HTML! Downloaded "${filename}" (${fileSizeMB} MB, ${pages.length} pages)`, 'success');
                    },
                    x: 0,
                    y: 0,
                    width: 190, // A4 width minus margins
                    windowWidth: 794,
                    margin: [6, 6, 6, 6], // Small margins in mm
                    autoPaging: 'text',
                    html2canvas: {
                        scale: 1.2,
                        useCORS: false,
                        allowTaint: true,
                        backgroundColor: '#ffffff',
                        logging: false,
                        ignoreElements: (element) => {
                            return ['IMG', 'SVG', 'CANVAS', 'SCRIPT'].includes(element.tagName) ||
                                   element.classList.contains('controls') ||
                                   element.classList.contains('file-input') ||
                                   element.classList.contains('status') ||
                                   element.classList.contains('measurement-container');
                        }
                    }
                });
                
            } catch (error) {
                console.error('High-quality PDF generation error:', error);
                updateStatus('Error generating high-quality PDF. Please try the regular Print button or HTML downloads.', 'error');
            } finally {
                // ENHANCED: Restore original page styles after PDF generation
                if (typeof originalPageStyles !== 'undefined' && originalPageStyles && originalPageStyles.length > 0) {
                    const pages = Array.from(paginatedContent.querySelectorAll('.page'));
                    pages.forEach((page, idx) => {
                        if (originalPageStyles[idx]) {
                            const original = originalPageStyles[idx];
                            page.style.display = original.display || '';
                            page.style.visibility = original.visibility || '';
                            page.style.position = original.position || '';
                            page.style.opacity = original.opacity || '';
                        }
                    });
                }
                
                // Reset flag and re-enable download button
                isPDFGenerating = false;
                const downloadButton = document.querySelector('[onclick="downloadPDF()"]');
                if (downloadButton) {
                    downloadButton.disabled = false;
                    downloadButton.textContent = 'High Quality PDF';
                }
            }
            
            // Close dropdown
            document.getElementById('downloadMenu').classList.remove('show');
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
    </div>
</body>
</html>
