<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal HTML to Print Paginator v2</title>
    <!-- jsPDF and html2canvas for direct PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* Print styles */
        @page {
            size: A4;
            margin: 0;
        }

        @media print {
            /* ULTIMATE OVERRIDE: Reset everything for absolute print control */
            *, *::before, *::after {
                -webkit-print-color-adjust: exact !important;
                color-adjust: exact !important;
                box-sizing: border-box !important;
            }
            
            html, body {
                margin: 0 !important;
                padding: 0 !important;
                background: white !important;
                max-width: none !important;
                overflow: visible !important;
                height: auto !important;
                min-height: auto !important;
            }
            
            /* ABSOLUTE PAGE CONTROL: Force Chrome to treat each page as a separate print page */
            .page {
                page-break-after: always !important;
                page-break-before: auto !important;
                page-break-inside: avoid !important;
                break-after: page !important;
                break-before: auto !important;
                break-inside: avoid-page !important;
                margin: 0 !important;
                padding: 0.6cm !important;
                box-shadow: none !important;
                border: none !important;
                background: white !important;
                width: 210mm !important;
                height: 297mm !important;
                max-height: 297mm !important;
                min-height: 297mm !important;
                display: block !important;
                overflow: hidden !important;
                position: relative !important;
                contain: layout style paint size !important;
                isolation: isolate !important;
            }
            
            .page:last-child {
                page-break-after: auto !important;
                break-after: auto !important;
            }
            
            /* ATOMIC CONTENT: Make page content indivisible */
            .page-content {
                page-break-inside: avoid !important;
                break-inside: avoid-page !important;
                height: auto !important;
                max-height: 285.4mm !important;
                overflow: visible !important;
                display: block !important;
                contain: layout style !important;
            }
            
            /* NUCLEAR OVERRIDE: Every element within pages is indivisible */
            .page *, .page *::before, .page *::after {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                page-break-before: auto !important;
                break-before: auto !important;
                page-break-after: auto !important;
                break-after: auto !important;
            }
            
            /* MAXIMUM TABLE PROTECTION */
            table, caption, thead, tbody, tfoot, tr, th, td {
                page-break-inside: avoid !important;
                break-inside: avoid-page !important;
                page-break-before: auto !important;
                break-before: auto !important;
                page-break-after: auto !important;
                break-after: auto !important;
                overflow: visible !important;
                contain: none !important;
            }
            
            /* STYLED CONTAINER ABSOLUTE PROTECTION */
            .callout, [class*="callout"], .warning, .success, .info, .alert, .card, .box,
            div[style*="background"], div[style*="border"], div[style*="box-shadow"],
            div[style*="padding"], div[style*="margin"] {
                page-break-inside: avoid !important;
                break-inside: avoid-page !important;
                display: block !important;
                overflow: visible !important;
                contain: none !important;
            }
            
            /* HEADING COHESION */
            h1, h2, h3, h4, h5, h6 {
                page-break-after: avoid !important;
                break-after: avoid !important;
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                keep-with-next: always !important;
                contain: none !important;
            }
            
            /* TEXT FLOW CONTROL */
            p, ul, ol, li, blockquote, div, span {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                orphans: 4 !important;
                widows: 4 !important;
                contain: none !important;
            }
            
            /* HIDE NON-PRINT ELEMENTS */
            .controls, .file-input, .source-content, .status, .debug-info, .measurement-container {
                display: none !important;
                visibility: hidden !important;
            }
            
            /* FORCE PAGINATED CONTENT VISIBILITY */
            .paginated-content {
                display: block !important;
                visibility: visible !important;
                position: static !important;
                contain: none !important;
            }
            
            /* CHROME HACK: Force physical page dimensions */
            @page {
                size: A4 !important;
                margin: 0 !important;
                padding: 0 !important;
            }
        }

        /* General styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Helvetica, Arial, sans-serif;
            background: white;
            padding: 20px;
            line-height: 1.4;
            width: 100%;
            height: auto; /* Allow dynamic height expansion */
            min-height: 100vh;
        }
        
        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            height: auto; /* Allow dynamic height expansion */
            background: white;
        }

        /* Page container for screen view */
        .page {
            width: 210mm;
            min-height: 297mm;
            background: white;
            margin: 0 auto 20px auto;
            padding: 0.6cm;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #ccc;
            position: relative;
            page-break-after: always;
        }

        /* Page content area - Let JavaScript handle height constraints */
        .page-content {
            /* No height constraints - pure JavaScript pagination logic */
        }

        /* Controls */
        .controls {
            text-align: center;
            margin: 0 auto 30px auto;
            background: #f8f8f8;
            padding: 25px;
            border-radius: 12px;
            border: 2px solid #000;
            color: black;
            width: 800px;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .controls h2 {
            margin: 0 0 20px 0;
            font-size: 24px;
            font-weight: bold;
            font-family: Helvetica, Arial, sans-serif;
            color: black;
        }

        .controls button {
            padding: 10px 14px;
            margin: 0;
            border: 2px solid #000;
            background: #f0f8ff;
            color: black;
            cursor: pointer;
            border-radius: 8px;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
        }
        
        /* Download Dropdown Styles */
        .download-dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 280px;
            background: white;
            border: 2px solid #000;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            overflow: hidden;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s ease;
            font-size: 14px;
            line-height: 1.2;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background-color: #f0f8ff;
        }

        .dropdown-item small {
            display: block;
            color: #666;
            font-size: 11px;
            margin-top: 2px;
        }

        .button-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            flex-wrap: nowrap;
            margin-bottom: 20px;
        }
        
        .button-row button {
            flex: 0 0 auto;
        }

        .controls button:hover {
            background: #e0f0ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .controls button:disabled {
            background: #ccc !important;
            color: #666 !important;
            cursor: not-allowed !important;
            opacity: 0.6 !important;
            transform: none !important;
            box-shadow: none !important;
        }

        .controls button:disabled:hover {
            background: #ccc !important;
            transform: none !important;
            box-shadow: none !important;
        }
        
        /* Workflow step indicators */
        .workflow-step {
            display: inline-block;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #ccc;
            color: white;
            text-align: center;
            line-height: 24px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        .workflow-step.completed {
            background: #4CAF50;
        }
        
        .workflow-step.active {
            background: #2196F3;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .controls button.primary {
            background: #4CAF50;
            color: white;
            border-color: #000;
        }

        .controls button.primary:hover {
            background: #45a049;
        }

        /* File input area */
        .file-input {
            background: #fffef7;
            border: 2px solid #000;
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            margin: 20px 0;
            font-family: Helvetica, Arial, sans-serif;
        }

        .file-input:hover {
            background: #fff8e1;
        }

        .file-input.dragover {
            border-color: #4CAF50;
            background: #f9f9f9;
        }

        .upload-button {
            margin: 15px 0;
            padding: 12px 30px;
            border: 2px solid #000;
            border-radius: 25px;
            background: #f0f8ff;
            color: black;
            font-family: Helvetica, Arial, sans-serif;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .upload-button:hover {
            background: #e0f0ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .html-input {
            width: 100%;
            height: 200px;
            margin: 10px 0;
            padding: 15px;
            border: 2px solid #000;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            font-weight: normal;
            background: #f8fff8;
            resize: vertical;
        }
        
        .html-input:focus {
            outline: none;
            background: #f0fff0;
        }

        /* Source content (shown initially) */
        .source-content {
            display: block;
            width: 800px;
            max-width: 100%;
            height: auto; /* Allow full height expansion */
            min-height: auto; /* Remove height constraints */
            margin: 0 auto 20px auto;
            background: white;
            padding: 0.6cm;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #ccc;
            box-sizing: border-box;
            overflow: visible; /* Ensure content is not clipped */
        }

        /* Styling for extracted page content */
        .source-content .extracted-page-content {
            display: block;
            width: 100%;
            margin-bottom: 20px;
            line-height: 1.45;
            color: #111;
        }
        
        .source-content .extracted-page-content > * {
            margin-bottom: 12px;
        }
        
        .source-content .extracted-page-content table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            border: 1px solid #000;
            border-radius: 8px;
            overflow: hidden;
            background: #fff;
            margin: 15px 0;
        }
        
        .source-content .extracted-page-content thead {
            display: table-header-group;
        }
        
        .source-content .extracted-page-content thead th {
            background: #fafafa;
            font-weight: bold;
        }
        
        .source-content .extracted-page-content tbody {
            display: table-row-group;
        }
        
        .source-content .extracted-page-content th,
        .source-content .extracted-page-content td {
            padding: 8px 10px;
            border-right: 1px solid #000;
            border-bottom: 1px solid #000;
            vertical-align: top;
            text-align: left;
        }
        
        .source-content .extracted-page-content th:last-child,
        .source-content .extracted-page-content td:last-child {
            border-right: none;
        }
        
        .source-content .extracted-page-content tbody tr:last-child td {
            border-bottom: none;
        }
        
        .source-content .extracted-page-content tbody tr:nth-child(even) td {
            background: #f5f5f5;
        }
        
        .source-content .extracted-page-content .callout {
            border-left: 4px solid #ccc;
            padding: 10px 15px;
            margin: 15px 0;
            background: #f8f8f8;
        }
        
        .source-content .extracted-page-content .callout.warning {
            border-left-color: #ff6b35;
            background: #fff3f0;
        }
        
        .source-content .extracted-page-content .callout.note {
            border-left-color: #4a90e2;
            background: #f0f7ff;
        }
        
        .source-content .extracted-page-content .meta {
            color: #666;
            font-size: 0.9em;
        }
        
        .source-content .extracted-page-content h1,
        .source-content .extracted-page-content h2,
        .source-content .extracted-page-content h3,
        .source-content .extracted-page-content h4,
        .source-content .extracted-page-content h5,
        .source-content .extracted-page-content h6 {
            font-weight: bold;
            margin: 0 0 12px 0;
        }
        
        .source-content .extracted-page-content p,
        .source-content .extracted-page-content ul,
        .source-content .extracted-page-content ol {
            margin: 0 0 12px 0;
        }
        
        /* Paginated content container */
        .paginated-content {
            margin: 0 auto;
            max-width: 1200px;
        }

        /* Ensure content fits properly within page bounds */
        .source-content *,
        .page-content * {
            max-width: 100%;
            box-sizing: border-box;
        }

        /* Status and debug info */
        .status {
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
            color: #666;
            display: none !important; /* Hide status messages from display */
        }


        /* Measurement container (hidden) */
        .measurement-container {
            position: absolute;
            top: -9999px;
            left: -9999px;
            visibility: hidden;
            width: 210mm;
            padding: 0.6cm;
        }
    </style>
</head>
<body>
    <div class="main-container">
    <div class="controls">
        <h2>Universal HTML to Print Paginator v2</h2>
        <p>Transform any HTML content into perfectly paginated A4 print layouts</p>
        
        <div class="file-input" id="fileInput">
            <p style="margin-bottom: 15px;"><strong>Method 1:</strong> Upload HTML File</p>
            <input type="file" accept=".html,.htm" id="htmlFile" style="display: none;">
            <button class="upload-button" onclick="document.getElementById('htmlFile').click()">📁 Choose HTML File</button>
        </div>
        
        <div class="button-row">
            <button onclick="processHTML()" id="processBtn" class="primary">
                <span class="workflow-step active" id="step1">1</span>✨ Process HTML
            </button>
            
            <button onclick="paginateContent()" id="paginateBtn" disabled>
                <span class="workflow-step" id="step2">2</span>📖 Paginate
            </button>
            
            <button onclick="printPaginated()" id="printBtn" disabled>
                <span class="workflow-step" id="step3a">3</span>🖨️ Print
            </button>
            
            <div class="download-dropdown" id="downloadDropdown">
                <button id="downloadBtn" disabled style="background: #e74c3c; border-color: #000;" onclick="toggleDownloadMenu()">
                    <span class="workflow-step" id="step3b">3</span>📥 Download ▼
                </button>
                <div class="dropdown-menu" id="downloadMenu">
                    <div class="dropdown-item" onclick="downloadProcessedHTML()">
                        📄 Download Processed HTML
                        <small>Exact as rendered on screen</small>
                    </div>
                    <div class="dropdown-item" onclick="downloadPaginatedHTML()">
                        📖 Download Paginated HTML
                        <small>All pages as single HTML file</small>
                    </div>
                    <div class="dropdown-item" onclick="console.log('PDF dropdown clicked'); downloadPDF();">
                        📄 Download High-Quality PDF
                        <small>Faithful reproduction of pages</small>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 15px; padding: 12px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; font-size: 13px; color: #856404;">
            <strong>📋 Print Settings:</strong> For perfect results, set Chrome print margins to <strong>"None"</strong> (not Default). Keep scale at 100% and paper size as A4. <br>
            <strong>💡 Best Quality:</strong> Use <strong>"Download PDF"</strong> for direct PDF generation that captures your perfect pagination exactly as shown on screen!
        </div>
    </div>

    <div class="status" id="status" style="display: none !important; visibility: hidden !important;">Ready - Upload HTML file or paste content above</div>
    

    <!-- Hidden measurement container -->
    <div class="measurement-container" id="measurementContainer">
        <!-- Cloned content for measurement will go here -->
    </div>

    <!-- Source content container -->
    <div class="source-content" id="sourceContent" style="display: none;">
        <!-- Original content will be displayed here -->
    </div>

    <!-- Paginated content container -->
    <div class="paginated-content" id="paginatedContent">
        <!-- Paginated pages will be generated here -->
    </div>

    <script>
        let originalHTML = '';
        let processedElements = [];
        let elementHeights = [];
        let preservedStyles = ''; // Store extracted styles globally
        let uploadedHTMLContent = ''; // Store uploaded HTML content
        let originalFileName = ''; // Store original filename for downloads
        let isPDFGenerating = false; // Prevent concurrent PDF downloads

        // Download dropdown toggle function
        function toggleDownloadMenu() {
            const menu = document.getElementById('downloadMenu');
            menu.classList.toggle('show');
            
            // Close dropdown when clicking outside
            if (menu.classList.contains('show')) {
                document.addEventListener('click', closeDropdownOnOutsideClick);
            }
        }

        function closeDropdownOnOutsideClick(event) {
            const dropdown = document.getElementById('downloadDropdown');
            if (!dropdown.contains(event.target)) {
                document.getElementById('downloadMenu').classList.remove('show');
                document.removeEventListener('click', closeDropdownOnOutsideClick);
            }
        }

        // Download Processed HTML as exact rendered version
        async function downloadProcessedHTML() {
            const sourceContent = document.getElementById('sourceContent');
            if (!sourceContent || !sourceContent.innerHTML.trim()) {
                alert('Please process HTML content first before downloading.');
                return;
            }

            updateStatus('Preparing processed HTML for download...');

            try {
                // Temporarily show the source content to ensure proper extraction
                const originalDisplay = sourceContent.style.display;
                sourceContent.style.display = 'block';
                
                // Create complete HTML document
                const htmlContent = createCompleteHTMLDocument(sourceContent, 'Processed Document');
                
                // Restore original display state
                sourceContent.style.display = originalDisplay;
                
                // Create download
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                
                const baseFileName = originalFileName || 'document';
                a.href = url;
                a.download = `${baseFileName}_processed.html`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                updateStatus('✅ Processed HTML downloaded successfully!', 'success');
                
            } catch (error) {
                console.error('Error downloading processed HTML:', error);
                updateStatus('Error downloading processed HTML.', 'error');
            }
            
            // Close dropdown
            document.getElementById('downloadMenu').classList.remove('show');
        }

        // Download Paginated HTML as complete document
        async function downloadPaginatedHTML() {
            const paginatedContent = document.getElementById('paginatedContent');
            if (!paginatedContent.children.length) {
                alert('Please paginate the content first before downloading.');
                return;
            }

            updateStatus('Preparing paginated HTML for download...');

            try {
                // Create complete HTML document with all pages
                const htmlContent = createCompleteHTMLDocument(paginatedContent, 'Paginated Document');
                
                // Create download
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                
                const baseFileName = originalFileName || 'document';
                const pageCount = paginatedContent.children.length;
                a.href = url;
                a.download = `${baseFileName}_paginated.html`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                updateStatus(`✅ Paginated HTML downloaded successfully! (${pageCount} pages)`, 'success');
                
            } catch (error) {
                console.error('Error downloading paginated HTML:', error);
                updateStatus('Error downloading paginated HTML.', 'error');
            }
            
            // Close dropdown
            document.getElementById('downloadMenu').classList.remove('show');
        }

        // Helper function to create complete HTML document with embedded styles
        function createCompleteHTMLDocument(contentElement, title) {
            // Extract all stylesheets from the current page
            const stylesheets = Array.from(document.querySelectorAll('style, link[rel="stylesheet"]'))
                .map(el => {
                    if (el.tagName === 'STYLE') {
                        return el.outerHTML;
                    } else {
                        // For external stylesheets, we'll need to inline them
                        return `<style>/* External stylesheet: ${el.href} */</style>`;
                    }
                }).join('\n        ');

            // Get the content HTML
            const contentHTML = contentElement.outerHTML;

            // Create complete document
            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    ${stylesheets}
</head>
<body>
    ${contentHTML}
    <script>
        // Simple script to handle print functionality if needed
        function printDocument() {
            window.print();
        }
    <\/script>
</body>
</html>`;
        }

        // Initialize the application
        function init() {
            console.log('Universal HTML Paginator v2 initialized');
            
            // Force hide status element to prevent console output display
            const statusElement = document.getElementById('status');
            if (statusElement) {
                statusElement.style.display = 'none';
                statusElement.style.visibility = 'hidden';
                statusElement.style.position = 'absolute';
                statusElement.style.top = '-9999px';
            }
            
            // Initialize workflow states - only step 1 is active, others disabled
            document.getElementById('step1').className = 'workflow-step active';
            document.getElementById('step2').className = 'workflow-step';
            document.getElementById('step3a').className = 'workflow-step';
            document.getElementById('step3b').className = 'workflow-step';
            
            // Initial button states
            document.getElementById('processBtn').disabled = false;
            document.getElementById('paginateBtn').disabled = true;
            document.getElementById('printBtn').disabled = true;
            document.getElementById('downloadBtn').disabled = true;
            
            // Set up file input handlers
            const fileInput = document.getElementById('htmlFile');
            const fileInputArea = document.getElementById('fileInput');
            
            fileInput.addEventListener('change', handleFileSelect);
            
            // Set up drag and drop
            fileInputArea.addEventListener('dragover', handleDragOver);
            fileInputArea.addEventListener('drop', handleDrop);
            fileInputArea.addEventListener('dragenter', (e) => {
                e.preventDefault();
                fileInputArea.classList.add('dragover');
            });
            fileInputArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                fileInputArea.classList.remove('dragover');
            });
        }

        // Handle file selection
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && (file.type === 'text/html' || file.name.endsWith('.html') || file.name.endsWith('.htm'))) {
                // Store original filename (without extension) for downloads
                originalFileName = file.name.replace(/\.(html|htm)$/i, '');
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    uploadedHTMLContent = e.target.result;
                    updateStatus('HTML file loaded successfully');
                    
                    // Reset button states for new file upload - allow fresh processing cycle
                    document.getElementById('paginateBtn').disabled = true; // Will be enabled after processing
                };
                reader.readAsText(file);
            } else {
                updateStatus('Please select a valid HTML file', 'error');
            }
        }

        // Handle drag and drop
        function handleDragOver(event) {
            event.preventDefault();
        }

        function handleDrop(event) {
            event.preventDefault();
            document.getElementById('fileInput').classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'text/html' || file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                    // Store original filename (without extension) for downloads
                    originalFileName = file.name.replace(/\.(html|htm)$/i, '');
                    
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        uploadedHTMLContent = e.target.result;
                        updateStatus('HTML file dropped and loaded successfully');
                        
                        // Reset button states for new file upload - allow fresh processing cycle
                        document.getElementById('paginateBtn').disabled = true; // Will be enabled after processing
                    };
                    reader.readAsText(file);
                } else {
                    updateStatus('Please drop a valid HTML file', 'error');
                }
            }
        }

        // Update status message
        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            if (status) {
                status.textContent = message;
                status.style.color = type === 'error' ? '#d32f2f' : type === 'success' ? '#388e3c' : '#666';
                status.style.display = 'none'; // Force hide status messages
                status.style.visibility = 'hidden'; // Double ensure it's hidden
            }
            // For debugging, log to console instead of showing on page
            console.log(`[Status] ${message}`);
        }


        // Print paginated content only
        function printPaginated() {
            // Ensure paginated content is visible
            document.getElementById('sourceContent').style.display = 'none';
            document.getElementById('paginatedContent').style.display = 'block';
            
            // Check if we have paginated content
            const paginatedContent = document.getElementById('paginatedContent');
            if (!paginatedContent.children.length) {
                alert('Please paginate the content first before printing.');
                return;
            }
            
            updateStatus('Preparing paginated content for print...');
            // Print
            window.print();
        }


        // Show paginated content
        function showPaginated() {
            document.getElementById('sourceContent').style.display = 'none';
            document.getElementById('paginatedContent').style.display = 'block';
            updateStatus('Showing paginated content');
        }

        // CSS Sanitization Engine - remove pagination-breaking rules
        function sanitizeCSS(htmlContent) {
            console.log('Starting CSS sanitization...');
            
            // MINIMAL sanitization - preserve 100% visual fidelity
            // Only remove CSS rules that actually break pagination flow
            const problematicRules = [
                /page-break-[^;]*;/gi,
                /break-[^;]*;/gi,
                /@page[^}]*}/gi,
                /height:\s*100vh[^;]*;/gi,          // Remove viewport heights  
                /min-height:\s*100vh[^;]*;/gi,
                /height:\s*100%[^;]*;/gi,           // Remove 100% heights that cause issues
                /min-height:\s*100%[^;]*;/gi,
                /\.page-content\s*\{[^}]*overflow:\s*hidden[^}]*\}/gi,  // Remove overflow:hidden ONLY from page-content
                /height:\s*calc\([^)]*\)[^;]*;/gi,  // Remove calc() heights that constrain flow
                /max-height:\s*[^;]*vh[^;]*;/gi,    // Remove viewport-based max heights
                /width:\s*793px[^;]*;/gi,           // Remove hardcoded 793px width that breaks layout
                /body\s*\{[^}]*background[^}]*\}/gi // Remove body background that might cause artifacts
            ];
            
            let sanitized = htmlContent;
            problematicRules.forEach(rule => {
                sanitized = sanitized.replace(rule, '');
            });
            
            // Comprehensive CSS fixes for all common HTML document formatting issues
            const spacingPreservationCSS = `
            <style>
            /* ========== LIST FORMATTING ========== */
            ul, ol {
                padding-left: 2.5em !important;
            }
            
            /* ========== SPACING PRESERVATION ========== */
            /* Preserve spacing and styling for specific content elements */
            .page-content .stat-box,
            .source-content .stat-box {
                margin: 8pt 0 !important;
                background-color: #00CCCC !important; /* Ensure cyan background is preserved */
                color: white !important;
                padding: 10pt !important;
                border-radius: 4pt !important;
                text-align: center !important;
                font-weight: bold !important;
            }
            
            /* PRESERVE ORIGINAL TABLE STYLING - NO HARDCODED OVERRIDES */
            .page-content th,
            .source-content th {
                /* Let original CSS handle all table header styling completely */
                /* NO hardcoded colors - preserve whatever the original CSS specified */
            }
            .page-content .text-box {
                margin: 12pt 0 !important;
            }
            .page-content .callout {
                margin: 15px 0 !important;
                padding: 10px 15px !important;
            }
            
            /* Preserve spacing between paragraphs and special elements */
            .page-content p + .text-box,
            .page-content p + .callout,
            .page-content p + .stat-box {
                margin-top: 12pt !important;
            }
            .page-content .text-box + p,
            .page-content .callout + p,
            .page-content .stat-box + p {
                margin-top: 12pt !important;
            }
            .page-content p + p {
                margin-top: 1em !important;
            }
            
            /* Heading spacing */
            .page-content h1, .page-content h2, .page-content h3, .page-content h4, .page-content h5, .page-content h6 {
                margin-top: 1.5em !important;
                margin-bottom: 0.5em !important;
                color: inherit !important;
            }
            .page-content h1:first-child, .page-content h2:first-child, .page-content h3:first-child {
                margin-top: 0 !important;
            }
            
            /* ========== PROGRAMMATIC STYLE PRESERVATION PLACEHOLDER ========== */
            /* Styles will be dynamically generated by preserveVisualFidelity() function */
            /* This ensures 100% visual fidelity without hardcoding document-specific rules */
            
            /* ========== CONTAINER FIXES ========== */
            /* MINIMAL container fixes - only remove problematic overlays, preserve visual styling */
            
            /* Only remove extra white overlays that block visual elements - preserve intentional styling */
            .page-content .table-container:not([style*="background:"]):not([class*="styled"]) {
                background: transparent !important;
                box-shadow: none !important;
            }
            
            /* Remove only unintentional white container backgrounds that create artifacts */
            .page-content .container:not([style*="background:"]):not(.stat-box):not(.text-box):not(.callout):not(.reference-box) {
                background: transparent !important;
                box-shadow: none !important;
            }
            
            /* Preserve margins for styled elements */
            .page-content div[style*="margin"] {
                margin: inherit !important;
            }
            .page-content div[class*="card"] {
                margin: inherit !important;
            }
            .page-content div[class*="container"] {
                margin: inherit !important;
            }
            .page-content div[style*="background"] {
                margin: inherit !important;
            }
            .page-content div[style*="border"] {
                margin: inherit !important;
            }
            
            /* ========== TEXT AND COLOR FIXES ========== */
            /* Ensure text remains visible */
            .page-content p, .page-content li, .page-content span {
                color: inherit !important;
            }
            
            /* Link styling preservation */
            .page-content a {
                color: #3498db !important;
                text-decoration: none !important;
            }
            .page-content a:hover {
                text-decoration: underline !important;
            }
            
            /* ========== BACKGROUND FIXES ========== */
            /* Remove problematic backgrounds that cause artifacts */
            .page-content body {
                background: transparent !important;
            }
            .page-content html {
                background: transparent !important;
            }
            
            /* Preserve intended backgrounds for content elements */
            .page-content .stat-box,
            .page-content .text-box,
            .page-content .callout,
            .page-content .reference-box,
            .page-content [class*="box"],
            .page-content [style*="background-color"],
            .page-content [style*="background:"] {
                background: inherit !important;
            }
            
            /* ========== GENERAL SPACING ========== */
            /* Preserve general spacing between elements */
            .page-content * + * {
                margin-top: inherit !important;
            }
            
            /* Ensure section and article elements maintain their margins */
            .page-content div, 
            .page-content section, 
            .page-content article {
                margin-bottom: inherit !important;
                margin-top: inherit !important;
            }
            
            /* ========== PRINT SAFETY ========== */
            /* Ensure content doesn't get clipped or hidden */
            .page-content * {
                max-width: 100% !important;
                box-sizing: border-box !important;
                overflow: visible !important;
            }
            
            /* ========== SOURCE CONTENT SCROLLABILITY FIXES ========== */
            /* TARGETED fix for scrollability - preserve 100% visual fidelity */
            /* Only override constraints that prevent scrolling in source view */
            
            .source-content {
                height: auto !important;
                min-height: auto !important;
                max-height: none !important;
                overflow: visible !important;
                /* SURGICAL FIX: Ensure perfect centering for both cloud.html and ml.html */
                display: block !important;
                margin: 0 auto 20px auto !important;
                width: 800px !important;
                max-width: 100% !important;
                position: relative !important;
                left: auto !important;
                right: auto !important;
            }
            
            /* Allow fixed-height documents to scroll in source view while preserving visuals */
            .source-content .page {
                height: auto !important;
                min-height: auto !important;
                max-height: none !important;
                overflow: visible !important;
            }
            
            /* Allow absolute-positioned content to flow naturally in source view */
            .source-content .page-content {
                height: auto !important;
                min-height: auto !important;
                max-height: none !important;
                overflow: visible !important;
            }
            
            /* ========== PAGINATED CONTENT PAGE SEPARATION ========== */
            /* CLEAN fix: Subtle page separation without background overlay */
            .paginated-content {
                padding: 20px 0 !important; /* Vertical padding for spacing */
                min-height: 100vh !important; /* Full viewport height */
            }
            
            .paginated-content .page {
                margin-bottom: 30px !important; /* Increased gap for cleaner separation */
                box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important; /* Subtle shadow */
                border: 1px solid #ddd !important; /* Very subtle border */
                margin-left: auto !important; /* Ensure centering */
                margin-right: auto !important; /* Ensure centering */
                display: block !important; /* Ensure block display */
                border-radius: 4px !important; /* Minimal rounded corners */
            }
            
            /* ========== CONTENT DISPLAY TOGGLE ========== */
            /* Ensure proper switching between processed and paginated content */
            .source-content[style*="display: none"] {
                display: none !important;
                visibility: hidden !important;
                height: 0 !important;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            .paginated-content[style*="display: block"] {
                display: block !important;
                visibility: visible !important;
            }
            
            .paginated-content[style*="display: none"] {
                display: none !important;
                visibility: hidden !important;
                height: 0 !important;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            /* ========== PRESERVE 100% VISUAL FIDELITY ========== */
            /* Remove any overrides that interfere with original styling */
            /* Let the original CSS handle all colors, backgrounds, fonts */
            </style>
            `;
            
            // Insert the spacing preservation CSS right after the opening <head> tag or before closing </head>
            if (sanitized.includes('</head>')) {
                sanitized = sanitized.replace('</head>', spacingPreservationCSS + '</head>');
            } else if (sanitized.includes('<head>')) {
                sanitized = sanitized.replace('<head>', '<head>' + spacingPreservationCSS);
            } else {
                // If no head tag, add it at the beginning
                sanitized = spacingPreservationCSS + sanitized;
            }
            
            return sanitized;
        }

        // Recursively extract granular content for optimal space utilization
        function extractGranularContent(element, container, processedElements) {
            const elementKey = element.outerHTML;
            
            // Skip if already processed
            if (processedElements.has(elementKey)) {
                return;
            }
            
            // Content elements that should be kept as-is
            const contentTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'TABLE', 'UL', 'OL', 'BLOCKQUOTE', 'PRE', 'IMG', 'FIGURE'];
            
            // If this is a content element, add it directly
            if (contentTags.includes(element.tagName)) {
                container.appendChild(element.cloneNode(true));
                processedElements.add(elementKey);
                console.log(`Added content element: ${element.tagName}.${element.className || 'no-class'}`);
                return;
            }
            
            // For container elements, check if they should be broken down
            if (element.children.length > 0) {
                const hasMultipleContentChildren = Array.from(element.children).filter(child => 
                    contentTags.includes(child.tagName) || child.children.length > 0
                ).length > 1;
                
                if (hasMultipleContentChildren) {
                    // Break down container - extract children individually
                    Array.from(element.children).forEach(child => {
                        extractGranularContent(child, container, processedElements);
                    });
                    console.log(`Broke down container: ${element.tagName}.${element.className || 'no-class'} into ${element.children.length} children`);
                } else {
                    // Keep container as-is (single content item or styled element)
                    container.appendChild(element.cloneNode(true));
                    processedElements.add(elementKey);
                    console.log(`Kept container: ${element.tagName}.${element.className || 'no-class'}`);
                }
            } else if (element.textContent.trim()) {
                // Text content without children
                container.appendChild(element.cloneNode(true));
                processedElements.add(elementKey);
                console.log(`Added text element: ${element.tagName}.${element.className || 'no-class'}`);
            }
        }
        
        // Programmatically preserve visual fidelity by capturing and enforcing all computed styles
        function preserveVisualFidelity(container) {
            console.log('Preserving visual fidelity with enhanced CSS preservation...');
            
            // ENHANCED APPROACH: Ensure original CSS is preserved AND augment with pagination fixes
            
            // First, make sure all original styles are preserved in the head
            if (preservedStyles && !document.head.querySelector('style[data-preserved="true"]')) {
                const preservedStyleElement = document.createElement('style');
                preservedStyleElement.setAttribute('data-preserved', 'true');
                preservedStyleElement.textContent = preservedStyles.replace(/<\/?style[^>]*>/g, '');
                document.head.appendChild(preservedStyleElement);
            }
            
            // Add enhanced pagination cleanup CSS that works with existing styles
            const enhancedCleanupCSS = `
/* ========== ENHANCED VISUAL FIDELITY PRESERVATION ========== */
/* Preserve all original styling while enabling pagination */

/* Force original styles to take precedence over any defaults */
.source-content *, .paginated-content * {
    /* Reset pagination breaks but preserve all visual styling */
    page-break-before: auto !important;
    page-break-after: auto !important; 
    page-break-inside: auto !important;
    break-before: auto !important;
    break-after: auto !important;
    break-inside: auto !important;
}

/* Ensure containers don't interfere with original styling */
.source-content, .paginated-content {
    /* Completely neutral container - NO style interference */
    all: unset;
    display: block;
    /* Let original CSS handle ALL styling completely */
}

/* Remove any fixed dimensions that could break layouts */
.page, .page-content {
    height: auto !important;
    min-height: auto !important;
    max-height: none !important;
}

/* Viewport page styling that doesn't interfere with content */
.viewport-page {
    page-break-after: always;
    margin: 0;
    padding: 0;
    /* Ensure we don't override any styling from original CSS */
    background: inherit;
    color: inherit;
    font-family: inherit;
}

.viewport-content {
    /* Minimal container that inherits all original styling */
    margin: 0;
    padding: 0;
    width: 100%;
    height: auto;
    /* Preserve all inherited styles */
    background: inherit;
    color: inherit;
    font-family: inherit;
    line-height: inherit;
}

/* ========== END ENHANCED PRESERVATION ========== */
            `;
            
            // Inject the enhanced cleanup CSS
            const styleElement = document.createElement('style');
            styleElement.setAttribute('data-enhanced', 'true');
            styleElement.textContent = enhancedCleanupCSS;
            
            const head = container.querySelector('head') || document.head;
            if (head) {
                head.appendChild(styleElement);
            } else {
                container.insertBefore(styleElement, container.firstChild);
            }
            
            console.log('Applied minimal pagination cleanup - trusting original CSS for all visuals');
            
            return container;
        }
        
        // Extract and normalize content - preserve individual elements AND styling
        function extractContent(htmlContent) {
            console.log('Extracting and normalizing content...');
            
            // Create a temporary container to parse the HTML
            const tempContainer = document.createElement('div');
            tempContainer.innerHTML = htmlContent;
            
            // Extract and preserve style tags
            const styleTags = Array.from(tempContainer.querySelectorAll('style'));
            preservedStyles = styleTags.map(style => style.outerHTML).join('\n'); // Store globally
            
            // Remove script tags for security and functionality
            const scripts = tempContainer.querySelectorAll('script');
            scripts.forEach(script => script.remove());
            
            // Get the body content, or the entire content if no body tag
            let content = tempContainer.querySelector('body') || tempContainer;
            
            // FLATTEN EXISTING PAGE STRUCTURE - remove .page containers but preserve layout hierarchy
            const pageContainers = content.querySelectorAll('.page');
            if (pageContainers.length > 0) {
                console.log(`Found pre-paginated structure with ${pageContainers.length} pages - flattening while preserving layout...`);
                
                // Smart flattening: preserve important layout containers while removing page wrappers
                const flattenedContent = document.createElement('div');
                const processedElements = new Set();
                
                pageContainers.forEach((pageContainer, pageIndex) => {
                    console.log(`Processing page ${pageIndex + 1} of ${pageContainers.length}`);
                    
                    // Get all direct children of the page container
                    const directChildren = Array.from(pageContainer.children);
                    
                    directChildren.forEach((child, childIndex) => {
                        // Skip page metadata elements
                        if (child.classList.contains('page-number') || 
                            child.classList.contains('report-footer') ||
                            child.classList.contains('page-header')) {
                            return;
                        }
                        
                        const childKey = child.outerHTML;
                        
                        // Skip if already processed
                        if (processedElements.has(childKey)) {
                            return;
                        }
                        
                        // Preserve layout containers like .two-column (with ALL nested content), .text-box, etc.
                        if (child.classList.contains('two-column') ||
                            child.classList.contains('text-box') ||
                            child.classList.contains('report-header') ||
                            child.tagName === 'SECTION' ||
                            child.tagName === 'ARTICLE' ||
                            (child.tagName === 'DIV' && child.children.length > 0 && 
                             (child.style.display === 'flex' || 
                              child.style.display === 'grid' ||
                              child.className.includes('container') ||
                              child.className.includes('row') ||
                              child.className.includes('layout')))) {
                            
                            // Keep the entire container structure intact with ALL nested content
                            flattenedContent.appendChild(child.cloneNode(true));
                            processedElements.add(childKey);
                            console.log(`Preserved complete layout container: ${child.tagName}.${child.className || 'no-class'} from page ${pageIndex + 1}`);
                            
                            // Also mark all nested elements as processed to avoid duplicates
                            const allNested = child.querySelectorAll('*');
                            allNested.forEach(nested => {
                                processedElements.add(nested.outerHTML);
                            });
                        }
                        // For content elements, add them directly
                        else if (['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'TABLE', 'UL', 'OL', 'BLOCKQUOTE', 'PRE', 'IMG', 'FIGURE'].includes(child.tagName)) {
                            flattenedContent.appendChild(child.cloneNode(true));
                            processedElements.add(childKey);
                            console.log(`Added content element: ${child.tagName}.${child.className || 'no-class'} from page ${pageIndex + 1}`);
                        }
                        // For other divs, check if they contain meaningful content
                        else if (child.tagName === 'DIV' && child.textContent.trim()) {
                            // Special handling for .page-content divs - extract their children but preserve context
                            if (child.classList.contains('page-content')) {
                                // Create a wrapper div to maintain styling context
                                const wrapper = document.createElement('div');
                                wrapper.className = 'extracted-page-content';
                                
                                Array.from(child.children).forEach(innerChild => {
                                    wrapper.appendChild(innerChild.cloneNode(true));
                                    console.log(`Added content from .page-content: ${innerChild.tagName}.${innerChild.className || 'no-class'} from page ${pageIndex + 1}`);
                                });
                                
                                flattenedContent.appendChild(wrapper);
                                processedElements.add(childKey);
                            } else {
                                // If it's a simple content div, preserve it
                                flattenedContent.appendChild(child.cloneNode(true));
                                processedElements.add(childKey);
                                console.log(`Added content div: ${child.className || 'no-class'} from page ${pageIndex + 1}`);
                            }
                        }
                    });
                });
                
                content = flattenedContent;
                console.log(`Smart flattening complete - extracted ${flattenedContent.children.length} elements while preserving layout hierarchy`);
            }
            
            // Return content as-is without adding extra containers that cause visual artifacts
            let finalHTML = '';
            
            // Add preserved styles first
            if (preservedStyles) {
                finalHTML += preservedStyles;
            }
            
            // Add each content element individually to preserve structure
            Array.from(content.children).forEach(child => {
                // Skip head elements and other non-content elements
                if (!['SCRIPT', 'STYLE', 'META', 'TITLE', 'HEAD', 'LINK'].includes(child.tagName)) {
                    finalHTML += child.outerHTML;
                }
            });
            
            return finalHTML;
        }

        // Update workflow step visual indicators and button states
        function updateWorkflowStep(step, status) {
            const stepElement = document.getElementById(`step${step}`);
            const step3aElement = document.getElementById('step3a');
            const step3bElement = document.getElementById('step3b');
            
            if (step === 1) {
                stepElement.className = status === 'completed' ? 'workflow-step completed' : 
                                       status === 'active' ? 'workflow-step active' : 'workflow-step';
                
                // Enable/disable paginate button
                document.getElementById('paginateBtn').disabled = status !== 'completed';
            } else if (step === 2) {
                stepElement.className = status === 'completed' ? 'workflow-step completed' : 
                                       status === 'active' ? 'workflow-step active' : 'workflow-step';
                
                // Enable/disable print and download buttons
                const enableButtons = status === 'completed';
                document.getElementById('printBtn').disabled = !enableButtons;
                document.getElementById('downloadBtn').disabled = !enableButtons;
                
                // Update step 3 indicators
                if (enableButtons) {
                    step3aElement.className = 'workflow-step active';
                    step3bElement.className = 'workflow-step active';
                } else {
                    step3aElement.className = 'workflow-step';
                    step3bElement.className = 'workflow-step';
                }
            }
        }

        // Process HTML input - just clean and show original
        async function processHTML() {
            try {
                const htmlInput = uploadedHTMLContent.trim();
                
                if (!htmlInput) {
                    updateStatus('Please upload an HTML file first', 'error');
                    return;
                }
                
                updateStatus('Processing and cleaning HTML...');
                
                // Step 1: Sanitize CSS
                const sanitizedHTML = sanitizeCSS(htmlInput);
                
                // Step 2: Extract and normalize content
                const normalizedContent = extractContent(sanitizedHTML);
                
                // Step 3: Store processed content for display first
                originalHTML = normalizedContent;
                document.getElementById('sourceContent').innerHTML = originalHTML;
                
                // Step 4: Preserve visual fidelity from the actually rendered content (with all CSS applied)
                // Wait longer for CSS to fully load and apply - this is critical for accurate inheritance
                await new Promise(resolve => requestAnimationFrame(resolve));
                await new Promise(resolve => setTimeout(resolve, 100)); // Additional delay for CSS resolution
                
                // Force reflow to ensure all styles are computed
                const sourceContainer = document.getElementById('sourceContent');
                sourceContainer.offsetHeight; // Force layout recalculation
                
                preserveVisualFidelity(sourceContainer);
                
                // Show processed content first to ensure elements are visible for measurement
                const sourceContent = document.getElementById('sourceContent');
                const paginatedContent = document.getElementById('paginatedContent');
                
                sourceContent.style.display = 'block';
                sourceContent.style.height = 'auto';
                sourceContent.style.minHeight = '100vh';
                sourceContent.style.maxHeight = 'none';
                sourceContent.style.overflow = 'visible';
                sourceContent.style.visibility = 'visible';
                sourceContent.style.position = 'static';
                paginatedContent.style.display = 'none';
                
                // Ensure all children are visible and have proper layout BEFORE measurement
                const allElements = sourceContent.querySelectorAll('*');
                allElements.forEach(elem => {
                    if (elem.style.display === 'none') elem.style.display = '';
                    if (elem.style.visibility === 'hidden') elem.style.visibility = 'visible';
                    if (elem.style.height === '0px') elem.style.height = 'auto';
                });
                
                // Force reflow before measurement
                sourceContent.offsetHeight;
                
                // Step 4: Prepare for measurement (but don't paginate yet) - NOW elements are visible
                await measureElements(normalizedContent);
                
                // Update workflow: Step 1 completed, enable Step 2
                updateWorkflowStep(1, 'completed');
                updateWorkflowStep(2, 'active');
                document.getElementById('paginateBtn').disabled = false;
                
                // Force multiple reflows to ensure proper rendering
                setTimeout(() => {
                    sourceContent.style.minHeight = 'auto';
                    sourceContent.offsetHeight; // Trigger reflow
                    setTimeout(() => {
                        // Final height adjustment
                        const computedHeight = sourceContent.scrollHeight;
                        sourceContent.style.minHeight = Math.max(computedHeight, window.innerHeight) + 'px';
                    }, 100);
                }, 50);
                
                updateStatus('HTML processed and cleaned! Ready for pagination.', 'success');
                
            } catch (error) {
                console.error('Error processing HTML:', error);
                updateStatus('Error processing HTML: ' + error.message, 'error');
            }
        }

        // Smart HTML structure analysis - understand containers vs content
        function analyzeHTMLStructure(element) {
            const contentElements = [];
            
            // Define what we consider "content containers" vs "layout containers"
            const contentTags = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'TABLE', 'UL', 'OL', 'BLOCKQUOTE', 'PRE', 'IMG', 'FIGURE'];
            const layoutContainers = ['DIV', 'SECTION', 'ARTICLE', 'MAIN', 'HEADER', 'FOOTER', 'ASIDE'];
            
            // Special classes that should NEVER be split across pages
            const indivisibleClasses = ['callout', 'warning', 'success', 'info', 'alert', 'card', 'box'];
            
            function traverseElement(el) {
                const tagName = el.tagName;
                const hasIndivisibleClass = indivisibleClasses.some(cls => el.classList.contains(cls));
                
                // Check if this element should be treated as indivisible
                if (hasIndivisibleClass) {
                    // Callout boxes and similar styled containers must not be split
                    contentElements.push({
                        element: el,
                        height: el.offsetHeight,
                        type: 'indivisible-content'
                    });
                    return; // Don't traverse children - treat as single unit
                }
                
                if (contentTags.includes(tagName)) {
                    // This is actual content - add it for measurement
                    if (tagName === 'TABLE') {
                        // Smart table handling - check if table should be treated as unit or split
                        const tableHeight = el.offsetHeight;
                        const maxTableHeight = 800; // Tables larger than this should be split
                        
                        if (tableHeight <= maxTableHeight) {
                            // Small/medium table - treat as indivisible unit
                            contentElements.push({
                                element: el,
                                height: tableHeight,
                                type: 'indivisible-content' // This prevents splitting
                            });
                        } else {
                            // Large table - extract rows for flexible pagination
                            const tbody = el.querySelector('tbody');
                            if (tbody) {
                                const rows = Array.from(tbody.querySelectorAll('tr'));
                                rows.forEach(row => {
                                    contentElements.push({
                                        element: row,
                                        height: row.offsetHeight,
                                        type: 'table-row',
                                        parentTable: el
                                    });
                                });
                            }
                        }
                    } else {
                        // Regular content element
                        contentElements.push({
                            element: el,
                            height: el.offsetHeight,
                            type: 'content'
                        });
                    }
                } else if (layoutContainers.includes(tagName)) {
                    // Check if this is a small styled container that should be treated as content
                    const computedStyle = window.getComputedStyle(el);
                    const hasVisualStyling = 
                        computedStyle.backgroundColor !== 'rgba(0, 0, 0, 0)' ||
                        computedStyle.borderRadius !== '0px' ||
                        computedStyle.backgroundImage !== 'none' ||
                        computedStyle.boxShadow !== 'none' ||
                        computedStyle.border !== '0px none rgb(51, 51, 51)' ||
                        el.style.background !== '';
                    
                    // Check if element has margins that suggest it's a spaced card
                    const marginBottom = parseFloat(computedStyle.marginBottom) || 0;
                    const marginTop = parseFloat(computedStyle.marginTop) || 0;
                    const hasSignificantMargins = marginBottom > 10 || marginTop > 10;
                    
                    // Only treat as content unit if it's small enough AND has visual styling OR significant margins
                    const elementHeight = el.offsetHeight;
                    const maxContentHeight = 400; // More conservative - only truly small elements should be indivisible
                    
                    // Be more selective about what we consider "indivisible"
                    const isSmallStyledElement = (hasVisualStyling || hasSignificantMargins) && elementHeight <= maxContentHeight;
                    const isCalloutOrCard = el.classList.contains('callout') || el.classList.contains('card') || el.classList.contains('note');
                    
                    if (isSmallStyledElement || (isCalloutOrCard && elementHeight <= 800)) {
                        // Small styled element or specific card types - treat as indivisible
                        contentElements.push({
                            element: el,
                            height: elementHeight,
                            type: 'indivisible-content'
                        });
                    } else {
                        // Large container or unstyled - traverse its children
                        Array.from(el.children).forEach(child => {
                            traverseElement(child);
                        });
                    }
                } else {
                    // Unknown element - treat as content if it has text/no children, container otherwise
                    if (el.children.length === 0 && el.textContent.trim()) {
                        // Text content
                        contentElements.push({
                            element: el,
                            height: el.offsetHeight,
                            type: 'content'
                        });
                    } else if (el.children.length > 0) {
                        // Has children - traverse
                        Array.from(el.children).forEach(child => {
                            traverseElement(child);
                        });
                    }
                }
            }
            
            traverseElement(element);
            return contentElements;
        }
        
        // Handle different content types with smart analysis
        function processContentByType(element) {
            return analyzeHTMLStructure(element);
        }

        // Enhanced measurement function with better accuracy and spacing preservation
        function getAccurateElementHeight(element) {
            // Instead of cloning to a hidden container, measure the element directly in place
            // This ensures all CSS styles are properly applied
            const elementStyle = window.getComputedStyle(element);
            
            // If element is currently visible, use its actual dimensions
            if (element.offsetHeight > 0) {
                const marginTop = parseFloat(elementStyle.marginTop) || 0;
                const marginBottom = parseFloat(elementStyle.marginBottom) || 0;
                const actualHeight = element.offsetHeight + marginTop + marginBottom;
                
                const buffer = (element.tagName === 'TABLE' || 
                               element.classList.contains('two-column') ||
                               element.classList.contains('text-box') ||
                               element.classList.contains('stat-box')) ? 8 : 4;
                
                // Element measurement: ${element.tagName}.${element.className || 'no-class'} - ${actualHeight + buffer}px
                return Math.ceil(actualHeight) + buffer;
            }
            
            // For elements with 0 height, create a better measurement container
            const tempContainer = document.createElement('div');
            tempContainer.style.cssText = `
                position: absolute;
                top: -9999px;
                left: -9999px;
                visibility: hidden;
                width: 800px;
                max-width: 100%;
                padding: 0.6cm;
                font-family: Helvetica, Arial, sans-serif;
                line-height: 1.4;
                font-size: 11pt;
                box-sizing: border-box;
                background: white;
            `;
            
            // Copy all stylesheets to ensure proper styling
            const allStyles = document.querySelectorAll('style, link[rel="stylesheet"]');
            allStyles.forEach(style => {
                if (style.tagName === 'STYLE') {
                    const newStyle = document.createElement('style');
                    newStyle.textContent = style.textContent;
                    tempContainer.appendChild(newStyle);
                }
            });
            
            // Clone the element and ensure it's visible
            const clonedElement = element.cloneNode(true);
            clonedElement.style.display = '';
            clonedElement.style.visibility = 'visible';
            clonedElement.style.height = 'auto';
            tempContainer.appendChild(clonedElement);
            document.body.appendChild(tempContainer);
            
            // Force layout calculation
            tempContainer.offsetHeight;
            
            // Get the accurate height including margins and borders
            const computedStyle = window.getComputedStyle(clonedElement);
            const marginTop = parseFloat(computedStyle.marginTop) || 0;
            const marginBottom = parseFloat(computedStyle.marginBottom) || 0;
            const paddingTop = parseFloat(computedStyle.paddingTop) || 0;
            const paddingBottom = parseFloat(computedStyle.paddingBottom) || 0;
            
            // Include full spacing in height calculation to preserve gaps between cards
            const actualHeight = clonedElement.offsetHeight + marginTop + marginBottom;
            
            // Clean up
            document.body.removeChild(tempContainer);
            
            // Reduced safety buffer for better space utilization
            const buffer = (clonedElement.tagName === 'TABLE' || 
                           clonedElement.classList.contains('two-column') ||
                           clonedElement.classList.contains('text-box') ||
                           clonedElement.classList.contains('stat-box')) ? 8 : 4; // Reduced buffer for better space usage
            
            // Element measured: ${element.tagName}.${element.className || 'no-class'} - ${actualHeight + buffer}px
            
            return Math.ceil(actualHeight) + buffer;
        }

        // Measure all elements in the content and add spacing between cards
        async function measureElements(content) {
            console.log('Starting enhanced element measurement...');
            
            const measurementContainer = document.getElementById('measurementContainer');
            measurementContainer.innerHTML = content;
            
            // Apply exact page styling to measurement container
            measurementContainer.style.cssText = `
                position: absolute;
                top: -9999px;
                left: -9999px;
                visibility: hidden;
                width: 210mm;
                padding: 0.6cm;
                font-family: Helvetica, Arial, sans-serif;
                line-height: 1.4;
                font-size: 11pt;
                box-sizing: border-box;
            `;
            
            // Force layout calculation
            measurementContainer.offsetHeight;
            
            // Get all top-level elements that should be measured individually
            // Handle both wrapped and unwrapped content
            let elements;
            if (measurementContainer.children.length === 1 && measurementContainer.children[0].children.length > 0) {
                // Content is wrapped in a container
                elements = Array.from(measurementContainer.children[0].children);
            } else {
                // Content is not wrapped or multiple top-level elements
                elements = Array.from(measurementContainer.children);
            }
            
            processedElements = [];
            elementHeights = [];
            
            console.log(`Total elements found: ${elements.length}`);
            // Elements detected for processing
            
            elements.forEach((element, index) => {
                const processedItems = processContentByType(element);
                
                processedItems.forEach((item, itemIndex) => {
                    // Use enhanced height measurement for better accuracy
                    const accurateHeight = getAccurateElementHeight(item.element);
                    item.height = accurateHeight;
                    
                    processedElements.push(item);
                    elementHeights.push(accurateHeight);
                    
                    // Enhanced measurement - Element ${index + 1}.${itemIndex + 1}: ${item.element.tagName}.${item.element.className || 'no-class'} - ${accurateHeight}px
                });
                
                // Add explicit spacing between elements (except after the last one)
                if (index < elements.length - 1) {
                    const currentStyle = window.getComputedStyle(element);
                    const nextElement = elements[index + 1];
                    const nextStyle = window.getComputedStyle(nextElement);
                    
                    const marginBottom = parseFloat(currentStyle.marginBottom) || 0;
                    const marginTop = parseFloat(nextStyle.marginTop) || 0;
                    
                    // Use margin collapse rules: max of the two margins
                    const spacing = Math.max(marginBottom, marginTop);
                    
                    if (spacing > 5) { // Only add spacing if there's a meaningful gap
                        const spacer = document.createElement('div');
                        spacer.style.height = spacing + 'px';
                        spacer.style.width = '100%';
                        spacer.style.backgroundColor = 'transparent';
                        spacer.className = 'spacing-element';
                        
                        const spacingItem = {
                            element: spacer,
                            height: spacing,
                            type: 'spacing'
                        };
                        
                        processedElements.push(spacingItem);
                        elementHeights.push(spacing);
                        
                        // Added spacing element: ${spacing}px between elements
                    }
                }
            });
            
            console.log(`Total elements measured (including spacing): ${processedElements.length}`);
            console.log('Height distribution:', elementHeights.sort((a, b) => b - a).slice(0, 10), '(top 10 largest)');
        }

        // Create a new page
        function createNewPage(pageNumber, needsTable = false, tableTemplate = null) {
            const page = document.createElement('div');
            page.className = 'page';
            
            const content = document.createElement('div');
            content.className = 'page-content';
            
            // PRESERVE CSS CONTEXT: Ensure paginated pages have same CSS environment as processed content
            // Copy the body class and any data attributes that might affect CSS inheritance
            const processedContent = document.getElementById('processedContent');
            if (processedContent) {
                const bodyElement = processedContent.closest('body') || document.body;
                if (bodyElement.className) {
                    page.classList.add(...bodyElement.className.split(' '));
                }
                
                // Copy any data attributes that affect styling
                Array.from(bodyElement.attributes).forEach(attr => {
                    if (attr.name.startsWith('data-') && !page.hasAttribute(attr.name)) {
                        page.setAttribute(attr.name, attr.value);
                    }
                });
            }
            
            // Add data attribute to help with CSS targeting
            content.setAttribute('data-preserve-spacing', 'true');
            
            if (needsTable && tableTemplate) {
                // Create table with header for table rows - preserve all styling
                const table = tableTemplate.cloneNode(true);
                const tbody = table.querySelector('tbody');
                if (tbody) tbody.innerHTML = ''; // Clear body, keep header
                
                // Preserve the table container structure from original
                const tableContainer = document.createElement('div');
                tableContainer.className = 'table-container';
                tableContainer.appendChild(table);
                content.appendChild(tableContainer);
            }
            
            page.appendChild(content);
            document.getElementById('paginatedContent').appendChild(page);
            
            // Initialize page height tracking
            pageHeights.set(page, 0);
            
            return { page, content, table: needsTable ? content.querySelector('table') : null };
        }

        // Track cumulative height per page
        const pageHeights = new Map(); // page -> cumulative height
        
        // Enhanced function to preserve computed styles when cloning elements
        function cloneElementWithStyles(originalElement) {
            const clone = originalElement.cloneNode(true);
            const originalStyles = window.getComputedStyle(originalElement);
            
            // Visual properties that must be preserved to maintain fidelity
            const criticalVisualProps = [
                'font-family', 'font-size', 'font-weight', 'font-style', 'line-height', 
                'color', 'background-color', 'background-image', 'background', 
                'border', 'border-radius', 'border-color', 'border-style', 'border-width',
                'padding', 'margin', 'text-align', 'text-decoration', 'text-transform',
                'box-shadow', 'opacity', 'gap'
            ];
            
            // Properties to exclude from cloning to prevent layout issues
            const excludeFromCloning = [
                'position', 'top', 'right', 'bottom', 'left', 'z-index',
                'width', 'height', 'min-width', 'min-height', 'max-width', 'max-height',
                'overflow', 'overflow-x', 'overflow-y', 'display'
            ];
            
            // Apply all critical visual properties as inline styles to ensure they're preserved
            criticalVisualProps.forEach(prop => {
                if (!excludeFromCloning.includes(prop)) {
                    const value = originalStyles.getPropertyValue(prop);
                    if (value && value !== 'none' && value !== 'auto' && value !== 'normal' && value !== 'initial') {
                        clone.style.setProperty(prop, value, 'important');
                    }
                }
            });
            
            // Let normal visual properties inheritance handle all table styling including border-radius
            
            // Recursively apply styles to all child elements
            const originalChildren = originalElement.querySelectorAll('*');
            const clonedChildren = clone.querySelectorAll('*');
            
            originalChildren.forEach((child, index) => {
                if (clonedChildren[index]) {
                    const childStyles = window.getComputedStyle(child);
                    criticalVisualProps.forEach(prop => {
                        if (!excludeFromCloning.includes(prop)) {
                            const value = childStyles.getPropertyValue(prop);
                            if (value && value !== 'none' && value !== 'auto' && value !== 'normal' && value !== 'initial') {
                                clonedChildren[index].style.setProperty(prop, value, 'important');
                            }
                        }
                    });
                }
            });
            
            return clone;
        }
        
        // Legacy function - keeping for compatibility
        function cloneElementWithStylesLegacy(originalElement) {
            const clone = originalElement.cloneNode(true);
            const originalStyles = window.getComputedStyle(originalElement);
            
            // Preserve ALL spacing and visual properties to maintain exact appearance
            const importantProps = [
                'margin-top', 'margin-bottom', 'margin-left', 'margin-right',
                'padding-top', 'padding-bottom', 'padding-left', 'padding-right',
                'border-top', 'border-bottom', 'border-left', 'border-right',
                'background-color', 'background-image', 'background-size', 'background-position',
                'border-radius', 'box-shadow', 'display'
            ];
            
            importantProps.forEach(prop => {
                const value = originalStyles.getPropertyValue(prop);
                if (value && value !== 'initial' && value !== 'normal') {
                    clone.style.setProperty(prop, value, 'important');
                }
            });
            
            // Preserve class names which may contain styling
            clone.className = originalElement.className;
            
            // Copy any inline styles
            if (originalElement.style.cssText) {
                clone.style.cssText += '; ' + originalElement.style.cssText;
            }
            
            return clone;
        }
        
        // Measure remaining space in page - use cumulative approach  
        function getRemainingSpace(page) {
            // Enhanced space utilization - more aggressive page filling
            // A4 is 297mm height. At 96 DPI: 297mm = 1123px approximately
            const pageHeightPx = 1123;
            // Reduce padding for better space utilization (was 23*2 = 46px, now 18*2 = 36px)
            const paddingPx = 18 * 2; // More aggressive padding for better space usage
            const availableHeight = pageHeightPx - paddingPx;
            
            // Get cumulative height for this page
            const currentHeight = pageHeights.get(page) || 0;
            const remainingSpace = availableHeight - currentHeight;
            
            console.log(`Page height: ${pageHeightPx}px, Available: ${availableHeight}px, Current: ${currentHeight}px, Remaining: ${remainingSpace}px`);
            
            return remainingSpace;
        }
        
        // Add element height to page tracking
        function addElementHeightToPage(page, elementHeight) {
            const currentHeight = pageHeights.get(page) || 0;
            pageHeights.set(page, currentHeight + elementHeight);
        }

        // Real-time cumulative height measurement during pagination
        function measureCumulativeHeight(pageContent) {
            // Create temporary page container with exact styling
            const tempPage = document.createElement('div');
            tempPage.className = 'page';
            tempPage.style.cssText = `
                position: absolute;
                top: -9999px;
                left: -9999px;
                visibility: hidden;
                width: 210mm;
                min-height: auto;
                background: white;
                padding: 0.6cm;
                box-sizing: border-box;
                font-family: Helvetica, Arial, sans-serif;
                line-height: 1.4;
                font-size: 11pt;
            `;
            
            // Clone all current page content
            const tempContent = document.createElement('div');
            tempContent.className = 'page-content';
            Array.from(pageContent.children).forEach(child => {
                tempContent.appendChild(child.cloneNode(true));
            });
            
            tempPage.appendChild(tempContent);
            document.body.appendChild(tempPage);
            
            // Force layout and measure - be more thorough
            tempPage.offsetHeight; // Force layout
            tempContent.offsetHeight; // Force content layout
            
            // Use the larger of scrollHeight and offsetHeight to ensure we capture all content
            const scrollHeight = tempContent.scrollHeight;
            const offsetHeight = tempContent.offsetHeight;
            const actualHeight = Math.max(scrollHeight, offsetHeight);
            
            console.log(`Height measurement: scrollHeight=${scrollHeight}, offsetHeight=${offsetHeight}, using=${actualHeight}`);
            
            // Cleanup
            document.body.removeChild(tempPage);
            
            return actualHeight;
        }

        // Main pagination logic - using real-time measurement
        // MARKER-BASED PAGINATION - REPLACES OLD COMPLEX ALGORITHM
        async function paginateContent() {
            const sourceContent = document.getElementById('sourceContent');
            if (!sourceContent || !sourceContent.innerHTML.trim()) {
                updateStatus('Please process HTML first before paginating', 'error');
                return;
            }
            
            console.log('=== STARTING MARKER-BASED PAGINATION ===');
            updateStatus('Creating paginated layout using A4 height markers...');
            
            // Clear existing paginated content and add preserved styles
            const paginatedContent = document.getElementById('paginatedContent');
            paginatedContent.innerHTML = '';
            
            // Add preserved styles to ensure proper styling in paginated content
            if (preservedStyles) {
                paginatedContent.insertAdjacentHTML('afterbegin', preservedStyles);
            }
            
            // A4 height calculation - available content height after margins
            const A4_HEIGHT = 1050; // Proper A4 content height in pixels (297mm ≈ 1123px - margins)
            console.log(`Target A4 height: ${A4_HEIGHT}px`);
            
            // Create a measurement container with the perfect processed content
            const measurementContainer = document.createElement('div');
            measurementContainer.style.cssText = `
                position: absolute;
                top: -9999px;
                left: -9999px;
                visibility: hidden;
                width: 210mm;
                padding: 0.6cm;
                font-family: Helvetica, Arial, sans-serif;
                line-height: 1.4;
                font-size: 11pt;
                background: white;
                box-sizing: border-box;
            `;
            
            // Clone the perfect processed content (with correct rounded corners!)
            measurementContainer.innerHTML = sourceContent.innerHTML;
            document.body.appendChild(measurementContainer);
            
            // Force layout calculation
            measurementContainer.offsetHeight;
            
            // Get all top-level elements from processed content
            const allElements = Array.from(measurementContainer.children);
            console.log(`Found ${allElements.length} top-level elements to paginate`);
            
            let currentPage = 1;
            let currentPageHeight = 0;
            let currentPageElements = [];
            let totalPages = 0;
            
            // Process each element and determine page breaks
            for (let i = 0; i < allElements.length; i++) {
                const element = allElements[i];
                const elementRect = element.getBoundingClientRect();
                const elementHeight = elementRect.height;
                
                console.log(`Element ${i + 1}: ${element.tagName}.${element.className || 'no-class'} - ${elementHeight.toFixed(1)}px`);
                
                // Special handling for tables - break at row level if too large
                if (element.tagName === 'TABLE' && elementHeight > A4_HEIGHT) {
                    console.log(`⚠️ Large table detected (${elementHeight.toFixed(1)}px > ${A4_HEIGHT}px) - breaking at row level`);
                    
                    // Finish current page if it has content
                    if (currentPageElements.length > 0) {
                        createPageFromElements(currentPageElements, currentPage, paginatedContent);
                        console.log(`✓ Created page ${currentPage} before large table with height ${currentPageHeight.toFixed(1)}px`);
                        totalPages++;
                        currentPage++;
                        currentPageHeight = 0;
                        currentPageElements = [];
                    }
                    
                    // Break table at row level with header preservation
                    const tablePages = breakTableIntoPages(element, A4_HEIGHT);
                    
                    for (const tablePage of tablePages) {
                        createPageFromElements([tablePage], currentPage, paginatedContent);
                        console.log(`✓ Created table page ${currentPage} with ${tablePage.querySelectorAll('tr').length} rows`);
                        totalPages++;
                        currentPage++;
                    }
                    
                    // Reset for next elements
                    currentPageHeight = 0;
                    currentPageElements = [];
                    
                } else {
                    // Regular element or small table - check if it fits
                    if (currentPageHeight + elementHeight > A4_HEIGHT && currentPageElements.length > 0) {
                        // Create page with current elements
                        createPageFromElements(currentPageElements, currentPage, paginatedContent);
                        console.log(`✓ Created page ${currentPage} with height ${currentPageHeight.toFixed(1)}px (${currentPageElements.length} elements)`);
                        totalPages++;
                        
                        // Start new page
                        currentPage++;
                        currentPageHeight = 0;
                        currentPageElements = [];
                    }
                    
                    // Add element to current page
                    currentPageElements.push(element);
                    currentPageHeight += elementHeight;
                }
            }
            
            // Create final page if there are remaining elements
            if (currentPageElements.length > 0) {
                createPageFromElements(currentPageElements, currentPage, paginatedContent);
                console.log(`✓ Created final page ${currentPage} with height ${currentPageHeight.toFixed(1)}px (${currentPageElements.length} elements)`);
                totalPages++;
            }
            
            // Cleanup measurement container
            document.body.removeChild(measurementContainer);
            
            // Update UI - show paginated content that preserves perfect visual fidelity
            updateStatus(`✅ Viewport pagination completed! Created ${totalPages} pages with perfect visual fidelity preserved.`, 'success');
            document.getElementById('paginatedContent').style.display = 'block';
            document.getElementById('sourceContent').style.display = 'none';
            
            // Update workflow: Step 2 completed
            updateWorkflowStep(2, 'completed');
            
            // Disable paginate button to prevent re-pagination and maintain visual fidelity
            document.getElementById('paginateBtn').disabled = true;
            
            console.log(`=== MARKER PAGINATION COMPLETED: ${totalPages} pages created ===`);
        }
        
        // COPY ENTIRE PROCESSED CONTENT AND SHOW/HIDE SECTIONS FOR EACH PAGE
        function createPageFromElements(elements, pageNumber, container) {
            // Create a page that contains a FULL COPY of the processed content
            const page = document.createElement('div');
            page.className = 'page viewport-page';
            page.setAttribute('data-page-number', pageNumber);
            
            // Get the entire processed content - find the active content container
            let processedContent = null;
            
            // First try to find visible containers
            const candidates = [
                document.getElementById('processedContent'),
                document.getElementById('sourceContent'),
                document.querySelector('.processed-content'),
                document.querySelector('#sourceContent'),
                document.querySelector('.source-content')
            ];
            
            // Find the first valid candidate that exists and has content
            for (let candidate of candidates) {
                if (candidate && candidate.children && candidate.children.length > 0) {
                    processedContent = candidate;
                    console.log(`Found content container: ${candidate.id || candidate.className}`);
                    break;
                }
            }
            
            if (!processedContent) {
                console.error('Could not find processed content container with children');
                console.log('Available containers:', candidates.filter(c => c).map(c => ({id: c.id, className: c.className, childrenCount: c.children.length})));
                return;
            }
            
            // Create a clean page with proper CSS inheritance
            // First, preserve the original CSS context by copying structure
            const pageContent = document.createElement('div');
            pageContent.className = processedContent.className;
            pageContent.id = `processedContent-page-${pageNumber}`;
            
            // Copy essential styles from the original processed content
            const computedStyles = window.getComputedStyle(processedContent);
            pageContent.style.cssText = `
                font-family: ${computedStyles.fontFamily};
                font-size: ${computedStyles.fontSize};
                line-height: ${computedStyles.lineHeight};
                color: ${computedStyles.color};
                background: ${computedStyles.background};
                width: 100%;
            `;
            
            // First, add any STYLE elements to ensure CSS is available
            const styleElements = processedContent.querySelectorAll('style');
            styleElements.forEach(styleEl => {
                const clonedStyle = styleEl.cloneNode(true);
                pageContent.appendChild(clonedStyle);
            });
            
            // Clone and append each element for this page while preserving context
            elements.forEach(originalElement => {
                if (originalElement.tagName === 'STYLE') {
                    // Skip style elements as they're already added above
                    return;
                }
                
                const clonedElement = originalElement.cloneNode(true);
                
                // For tables and text-boxes, ensure visual fidelity by preserving critical styles
                if (originalElement.tagName === 'TABLE' || originalElement.classList.contains('text-box')) {
                    const originalStyles = window.getComputedStyle(originalElement);
                    clonedElement.style.cssText += `
                        border-radius: ${originalStyles.borderRadius} !important;
                        background: ${originalStyles.background} !important;
                        background-color: ${originalStyles.backgroundColor} !important;
                        border: ${originalStyles.border} !important;
                        box-shadow: ${originalStyles.boxShadow} !important;
                        padding: ${originalStyles.padding} !important;
                        margin: ${originalStyles.margin} !important;
                    `;
                    
                    // Also preserve styles for child elements like table cells
                    const originalCells = originalElement.querySelectorAll('td, th');
                    const clonedCells = clonedElement.querySelectorAll('td, th');
                    originalCells.forEach((originalCell, index) => {
                        if (clonedCells[index]) {
                            const cellStyles = window.getComputedStyle(originalCell);
                            clonedCells[index].style.cssText += `
                                border-radius: ${cellStyles.borderRadius} !important;
                                background: ${cellStyles.background} !important;
                                background-color: ${cellStyles.backgroundColor} !important;
                                border: ${cellStyles.border} !important;
                                padding: ${cellStyles.padding} !important;
                                color: ${cellStyles.color} !important;
                            `;
                        }
                    });
                }
                
                pageContent.appendChild(clonedElement);
            });
            
            page.appendChild(pageContent);
            container.appendChild(page);
        }
        
        // Helper function to create a unique selector for an element
        function getElementSelector(element) {
            if (element.id) return `#${element.id}`;
            
            let selector = element.tagName.toLowerCase();
            if (element.className) {
                selector += '.' + element.className.replace(/\s+/g, '.');
            }
            
            // Add position among siblings for uniqueness
            const siblings = Array.from(element.parentElement.children).filter(s => 
                s.tagName === element.tagName && s.className === element.className
            );
            if (siblings.length > 1) {
                const index = siblings.indexOf(element);
                selector += `:nth-of-type(${index + 1})`;
            }
            
            return selector;
        }
        
        // Break large tables into multiple pages at row level with header preservation
        function breakTableIntoPages(table, maxPageHeight) {
            const tablePages = [];
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody') || table; // Handle tables without explicit tbody
            const rows = tbody.querySelectorAll('tr');
            
            console.log(`Breaking table with ${rows.length} rows (header: ${thead ? 'yes' : 'no'})`);
            
            let currentPageRows = [];
            let currentPageHeight = 0;
            
            // Calculate header height if present
            let headerHeight = 0;
            if (thead) {
                const tempTable = table.cloneNode(false);
                tempTable.appendChild(thead.cloneNode(true));
                document.body.appendChild(tempTable);
                tempTable.style.position = 'absolute';
                tempTable.style.top = '-9999px';
                tempTable.style.visibility = 'hidden';
                headerHeight = tempTable.getBoundingClientRect().height;
                document.body.removeChild(tempTable);
                console.log(`Table header height: ${headerHeight.toFixed(1)}px`);
            }
            
            // Reserve space for header on each page
            const availableHeight = maxPageHeight - headerHeight;
            
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                
                // Create temp table to measure row height
                const tempTable = table.cloneNode(false);
                const tempTbody = document.createElement('tbody');
                tempTbody.appendChild(row.cloneNode(true));
                tempTable.appendChild(tempTbody);
                document.body.appendChild(tempTable);
                tempTable.style.position = 'absolute';
                tempTable.style.top = '-9999px';
                tempTable.style.visibility = 'hidden';
                
                const rowHeight = tempTable.getBoundingClientRect().height;
                document.body.removeChild(tempTable);
                
                console.log(`Row ${i + 1}: ${rowHeight.toFixed(1)}px`);
                
                // Check if adding this row would exceed available height
                if (currentPageHeight + rowHeight > availableHeight && currentPageRows.length > 0) {
                    // Create table page with current rows
                    const tablePage = createTablePage(table, thead, currentPageRows);
                    tablePages.push(tablePage);
                    console.log(`Table page created with ${currentPageRows.length} rows (${currentPageHeight.toFixed(1)}px + ${headerHeight.toFixed(1)}px header)`);
                    
                    // Start new page
                    currentPageRows = [];
                    currentPageHeight = 0;
                }
                
                // Add row to current page
                currentPageRows.push(row);
                currentPageHeight += rowHeight;
            }
            
            // Create final table page if there are remaining rows
            if (currentPageRows.length > 0) {
                const tablePage = createTablePage(table, thead, currentPageRows);
                tablePages.push(tablePage);
                console.log(`Final table page created with ${currentPageRows.length} rows (${currentPageHeight.toFixed(1)}px + ${headerHeight.toFixed(1)}px header)`);
            }
            
            console.log(`Table broken into ${tablePages.length} pages`);
            return tablePages;
        }
        
        // Create a table page with header and specified rows - PRESERVES CSS CONTEXT
        function createTablePage(originalTable, thead, rows) {
            const tablePage = originalTable.cloneNode(false); // Clone table structure only
            
            // Add header to each page (if exists)
            if (thead) {
                tablePage.appendChild(thead.cloneNode(true));
            }
            
            // Add tbody with the rows for this page
            const tbody = document.createElement('tbody');
            rows.forEach(row => {
                tbody.appendChild(row.cloneNode(true));
            });
            tablePage.appendChild(tbody);
            
            return tablePage;
        }

        // Download PDF using jsPDF - direct PDF generation
        async function downloadPDF() {
            console.log('downloadPDF function called');
            
            // Prevent concurrent PDF generation
            if (isPDFGenerating) {
                console.log('PDF generation already in progress, ignoring request');
                return;
            }
            
            const paginatedContent = document.getElementById('paginatedContent');
            if (!paginatedContent.children.length) {
                alert('Please paginate the content first before downloading PDF.');
                return;
            }
            
            // Check if required libraries are loaded
            if (typeof html2canvas === 'undefined') {
                updateStatus('Error: html2canvas library not loaded. Please check your internet connection.', 'error');
                alert('PDF generation requires internet connection to load html2canvas library.\n\nPlease:\n1. Check your internet connection\n2. Refresh the page\n3. Try again');
                return;
            }
            
            if (!window.jspdf) {
                updateStatus('Error: jsPDF library not loaded. Please check your internet connection.', 'error');
                alert('PDF generation requires internet connection to load jsPDF library.\n\nPlease:\n1. Check your internet connection\n2. Refresh the page\n3. Try again');
                return;
            }
            
            // Set flag and disable download button
            isPDFGenerating = true;
            const downloadButton = document.querySelector('[onclick="downloadPDF()"]');
            if (downloadButton) {
                downloadButton.disabled = true;
                downloadButton.textContent = 'Generating PDF...';
            }
            
            updateStatus('Generating high-quality PDF from your perfect layout... This may take a moment.');
            
            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                
                const pages = Array.from(paginatedContent.querySelectorAll('.page'));
                let pageIndex = 0;
                
                // A4 dimensions in mm
                const A4_WIDTH_MM = 210;
                const A4_HEIGHT_MM = 297;
                
                for (const page of pages) {
                    updateStatus(`Processing page ${pageIndex + 1} of ${pages.length}...`);
                    
                    if (pageIndex > 0) {
                        pdf.addPage();
                    }
                    
                    try {
                        // Calculate optimal scale based on page content dimensions
                        const pageRect = page.getBoundingClientRect();
                        const pageStyles = window.getComputedStyle(page);
                        const padding = parseFloat(pageStyles.paddingTop) + parseFloat(pageStyles.paddingBottom);
                        
                        // Use optimized scale for smaller file size while maintaining quality
                        const baseScale = 1.5; // Reduced from dynamic scaling to fixed 1.5x
                        
                        // Force page visibility for html2canvas
                        page.style.display = 'block';
                        page.style.visibility = 'visible';
                        page.style.position = 'static';
                        
                        console.log(`Page ${pageIndex + 1} dimensions: ${pageRect.width}x${pageRect.height}`);
                        
                        const canvas = await html2canvas(page, {
                            scale: baseScale,
                            useCORS: true,
                            allowTaint: true,
                            backgroundColor: '#ffffff',
                            width: pageRect.width,
                            height: pageRect.height,
                            scrollX: 0,
                            scrollY: 0,
                            removeContainer: false,
                            imageTimeout: 15000,
                            logging: true,
                            letterRendering: true,
                            foreignObjectRendering: true,
                            ignoreElements: (element) => {
                                // Skip hidden elements that might interfere
                                return element.style.display === 'none' || element.style.visibility === 'hidden';
                            }
                        });
                        
                        console.log(`Canvas ${pageIndex + 1} created: ${canvas.width}x${canvas.height}`);
                        
                        // Use JPEG with 85% quality for much smaller file size
                        const imgData = canvas.toDataURL('image/jpeg', 0.85);
                        
                        // Calculate proper dimensions to maintain aspect ratio
                        const canvasAspectRatio = canvas.width / canvas.height;
                        const pageAspectRatio = A4_WIDTH_MM / A4_HEIGHT_MM;
                        
                        let imgWidth, imgHeight, offsetX = 0, offsetY = 0;
                        
                        if (canvasAspectRatio > pageAspectRatio) {
                            // Canvas is wider than A4 ratio - fit to width
                            imgWidth = A4_WIDTH_MM;
                            imgHeight = A4_WIDTH_MM / canvasAspectRatio;
                            offsetY = (A4_HEIGHT_MM - imgHeight) / 2;
                        } else {
                            // Canvas is taller than A4 ratio - fit to height  
                            imgHeight = A4_HEIGHT_MM;
                            imgWidth = A4_HEIGHT_MM * canvasAspectRatio;
                            offsetX = (A4_WIDTH_MM - imgWidth) / 2;
                        }
                        
                        // Ensure we don't exceed A4 boundaries
                        if (imgHeight > A4_HEIGHT_MM) {
                            const scale = A4_HEIGHT_MM / imgHeight;
                            imgHeight = A4_HEIGHT_MM;
                            imgWidth *= scale;
                            offsetX = (A4_WIDTH_MM - imgWidth) / 2;
                            offsetY = 0;
                        }
                        
                        pdf.addImage(imgData, 'JPEG', offsetX, offsetY, imgWidth, imgHeight);
                        
                    } catch (pageError) {
                        console.error(`Error processing page ${pageIndex + 1}:`, pageError);
                        updateStatus(`Warning: Page ${pageIndex + 1} had rendering issues but continuing...`);
                    }
                    
                    pageIndex++;
                }
                
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const baseFileName = originalFileName || 'document';
                const filename = `${baseFileName}_paginated.pdf`;
                
                const pdfOutput = pdf.output('blob');
                const fileSizeMB = (pdfOutput.size / (1024 * 1024)).toFixed(2);
                
                pdf.save(filename);
                
                updateStatus(`✅ High-quality PDF generated successfully! Downloaded "${filename}" (${fileSizeMB} MB, ${pages.length} pages)`, 'success');
                
            } catch (error) {
                console.error('High-quality PDF generation error:', error);
                updateStatus('Error generating high-quality PDF. Please try the regular Print button or HTML downloads.', 'error');
            } finally {
                // Reset flag and re-enable download button
                isPDFGenerating = false;
                const downloadButton = document.querySelector('[onclick="downloadPDF()"]');
                if (downloadButton) {
                    downloadButton.disabled = false;
                    downloadButton.textContent = 'High Quality PDF';
                }
            }
            
            // Close dropdown
            document.getElementById('downloadMenu').classList.remove('show');
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
    </div>
</body>
</html>
